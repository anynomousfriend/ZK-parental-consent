import { ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { BaseV1Configuration, DefaultV1Configuration, V1Variant, CoreWallet, UnboundTransaction } from './v1/index.js';
import * as ledger from '@midnight-ntwrk/ledger-v7';
import * as rx from 'rxjs';
import { SerializationCapability } from './v1/Serialization.js';
import { TransactionHistoryService } from './v1/TransactionHistory.js';
import { CoinsAndBalancesCapability } from './v1/CoinsAndBalances.js';
import { KeysCapability } from './v1/Keys.js';
import { TokenTransfer, FinalizedTransactionBalanceResult, UnboundTransactionBalanceResult, UnprovenTransactionBalanceResult } from './v1/Transacting.js';
import { WalletSyncUpdate } from './v1/SyncSchema.js';
import { UtxoWithMeta } from './v1/UnshieldedState.js';
import { Variant, VariantBuilder, WalletLike } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { PublicKey } from './KeyStore.js';
import { SyncProgress } from './v1/SyncProgress.js';
import { UnshieldedUpdate } from './v1/SyncSchema.js';
import { UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
export type UnshieldedWalletCapabilities<TSerialized = string> = {
    serialization: SerializationCapability<CoreWallet, TSerialized>;
    coinsAndBalances: CoinsAndBalancesCapability<CoreWallet>;
    keys: KeysCapability<CoreWallet>;
    transactionHistory: TransactionHistoryService<UnshieldedUpdate>;
};
export declare class UnshieldedWalletState<TSerialized = string> {
    static readonly mapState: <TSerialized_1 = string>(capabilities: UnshieldedWalletCapabilities<TSerialized_1>) => (state: ProtocolState.ProtocolState<CoreWallet>) => UnshieldedWalletState<TSerialized_1>;
    readonly protocolVersion: ProtocolVersion.ProtocolVersion;
    readonly state: CoreWallet;
    readonly capabilities: UnshieldedWalletCapabilities<TSerialized>;
    get balances(): Record<ledger.RawTokenType, bigint>;
    get totalCoins(): readonly UtxoWithMeta[];
    get availableCoins(): readonly UtxoWithMeta[];
    get pendingCoins(): readonly UtxoWithMeta[];
    get address(): UnshieldedAddress;
    get progress(): SyncProgress;
    get transactionHistory(): TransactionHistoryService<UnshieldedUpdate>;
    constructor(state: ProtocolState.ProtocolState<CoreWallet>, capabilities: UnshieldedWalletCapabilities<TSerialized>);
    serialize(): TSerialized;
}
export type UnshieldedWallet = CustomizedUnshieldedWallet<WalletSyncUpdate, string>;
export type UnshieldedWalletClass = CustomizedUnshieldedWalletClass<WalletSyncUpdate, string, DefaultV1Configuration>;
export interface CustomizedUnshieldedWallet<TSyncUpdate = WalletSyncUpdate, TSerialized = string> extends WalletLike.WalletLike<[Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate>>]> {
    readonly state: rx.Observable<UnshieldedWalletState<TSerialized>>;
    start(): Promise<void>;
    balanceFinalizedTransaction(tx: ledger.FinalizedTransaction): Promise<FinalizedTransactionBalanceResult>;
    balanceUnboundTransaction(tx: UnboundTransaction): Promise<UnboundTransactionBalanceResult>;
    balanceUnprovenTransaction(tx: ledger.UnprovenTransaction): Promise<UnprovenTransactionBalanceResult>;
    transferTransaction(outputs: readonly TokenTransfer[], ttl: Date): Promise<ledger.UnprovenTransaction>;
    initSwap(desiredInputs: Record<ledger.RawTokenType, bigint>, desiredOutputs: readonly TokenTransfer[], ttl: Date): Promise<ledger.UnprovenTransaction>;
    signUnprovenTransaction(transaction: ledger.UnprovenTransaction, signSegment: (data: Uint8Array) => ledger.Signature): Promise<ledger.UnprovenTransaction>;
    signUnboundTransaction(transaction: UnboundTransaction, signSegment: (data: Uint8Array) => ledger.Signature): Promise<UnboundTransaction>;
    serializeState(): Promise<TSerialized>;
    waitForSyncedState(allowedGap?: bigint): Promise<UnshieldedWalletState<TSerialized>>;
    getAddress(): Promise<UnshieldedAddress>;
}
export interface CustomizedUnshieldedWalletClass<TSyncUpdate = WalletSyncUpdate, TSerialized = string, TConfig extends BaseV1Configuration = DefaultV1Configuration> extends WalletLike.BaseWalletClass<[Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate>>]> {
    configuration: TConfig;
    startWithPublicKey(publicKey: PublicKey): CustomizedUnshieldedWallet<TSyncUpdate, TSerialized>;
    restore(serializedState: TSerialized): CustomizedUnshieldedWallet<TSyncUpdate, TSerialized>;
}
export declare function UnshieldedWallet(configuration: DefaultV1Configuration): UnshieldedWalletClass;
export declare function CustomUnshieldedWallet<TConfig extends BaseV1Configuration = DefaultV1Configuration, TSyncUpdate = WalletSyncUpdate, TSerialized = string>(configuration: TConfig, builder: VariantBuilder.VariantBuilder<V1Variant<TSerialized, TSyncUpdate>, TConfig>): CustomizedUnshieldedWalletClass<TSyncUpdate, TSerialized, TConfig>;
