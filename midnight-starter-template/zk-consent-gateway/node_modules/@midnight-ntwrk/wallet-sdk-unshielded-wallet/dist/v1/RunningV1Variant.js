// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, pipe, Scope, Stream, SubscriptionRef, Schedule, Duration, Sink, Console } from 'effect';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { StateChange, VersionChangeType, } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';
const progress = (state) => {
    const appliedId = state.progress?.appliedId ?? 0n;
    const highestTransactionId = state.progress?.highestTransactionId ?? 0n;
    const sourceGap = highestTransactionId - appliedId;
    const applyGap = appliedId - appliedId;
    return [StateChange.ProgressUpdate({ sourceGap, applyGap })];
};
const protocolVersionChange = (previous, current) => {
    return previous.protocolVersion != current.protocolVersion
        ? [
            StateChange.VersionChange({
                change: VersionChangeType.Version({
                    version: ProtocolVersion.ProtocolVersion(current.protocolVersion),
                }),
            }),
        ]
        : [];
};
export const V1Tag = Symbol('V1');
export class RunningV1Variant {
    __polyTag__ = V1Tag;
    #scope;
    #context;
    #v1Context;
    state;
    constructor(scope, context, v1Context) {
        this.#scope = scope;
        this.#context = context;
        this.#v1Context = v1Context;
        this.state = Stream.fromEffect(context.stateRef.get).pipe(Stream.flatMap((initialState) => context.stateRef.changes.pipe(Stream.mapAccum(initialState, (previous, current) => {
            return [current, [previous, current]];
        }))), Stream.mapConcat(([previous, current]) => {
            // TODO: emit progress only upon actual change
            return [
                StateChange.State({ state: current }),
                ...progress(current),
                ...protocolVersionChange(previous, current),
            ];
        }));
    }
    startSyncInBackground() {
        return this.startSync().pipe(Stream.runScoped(Sink.drain), Effect.forkScoped, Effect.provideService(Scope.Scope, this.#scope));
    }
    startSync() {
        return pipe(SubscriptionRef.get(this.#context.stateRef), Stream.fromEffect, Stream.flatMap((state) => this.#v1Context.syncService.updates(state)), Stream.mapEffect((update) => {
            return SubscriptionRef.updateEffect(this.#context.stateRef, (state) => pipe(this.#v1Context.syncCapability.applyUpdate(state, update), EitherOps.toEffect));
        }), Stream.tapError((error) => Console.error(error)), Stream.retry(pipe(Schedule.exponential(Duration.seconds(1), 2), Schedule.map((delay) => {
            const maxDelay = Duration.minutes(2);
            const jitter = Duration.millis(Math.floor(Math.random() * 1000));
            const delayWithJitter = Duration.toMillis(delay) + Duration.toMillis(jitter);
            return Duration.millis(Math.min(delayWithJitter, Duration.toMillis(maxDelay)));
        }))));
    }
    balanceFinalizedTransaction(tx) {
        return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
            return pipe(this.#v1Context.transactingCapability.balanceFinalizedTransaction(state, tx), EitherOps.toEffect);
        });
    }
    balanceUnboundTransaction(tx) {
        return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
            return pipe(this.#v1Context.transactingCapability.balanceUnboundTransaction(state, tx), EitherOps.toEffect);
        });
    }
    balanceUnprovenTransaction(tx) {
        return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
            return pipe(this.#v1Context.transactingCapability.balanceUnprovenTransaction(state, tx), EitherOps.toEffect);
        });
    }
    transferTransaction(outputs, ttl) {
        return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
            return pipe(this.#v1Context.transactingCapability.makeTransfer(state, outputs, ttl), EitherOps.toEffect, Effect.map(({ transaction, newState }) => [transaction, newState]));
        });
    }
    initSwap(desiredInputs, desiredOutputs, ttl) {
        return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
            return pipe(this.#v1Context.transactingCapability.initSwap(state, desiredInputs, desiredOutputs, ttl), Effect.map(({ transaction, newState }) => [transaction, newState]));
        });
    }
    signUnprovenTransaction(transaction, signSegment) {
        return this.#v1Context.transactingCapability.signUnprovenTransaction(transaction, signSegment);
    }
    signUnboundTransaction(transaction, signSegment) {
        return this.#v1Context.transactingCapability.signUnboundTransaction(transaction, signSegment);
    }
    serializeState(state) {
        return this.#v1Context.serializationCapability.serialize(state);
    }
}
