import { Data, Either, HashMap } from 'effect';
import { ApplyTransactionError, UtxoNotFoundError } from './WalletError.js';
export class UtxoWithMeta extends Data.Class {
}
const UtxoHash = (utxo) => `${utxo.intentHash}#${utxo.outputNo}`;
export const UnshieldedState = {
    empty: () => ({
        availableUtxos: HashMap.empty(),
        pendingUtxos: HashMap.empty(),
    }),
    restore: (availableUtxos, pendingUtxos) => ({
        availableUtxos: HashMap.fromIterable(availableUtxos.map((utxo) => [UtxoHash(utxo.utxo), utxo])),
        pendingUtxos: HashMap.fromIterable(pendingUtxos.map((utxo) => [UtxoHash(utxo.utxo), utxo])),
    }),
    spend: (state, utxo) => Either.gen(function* () {
        const hash = UtxoHash(utxo.utxo);
        if (!HashMap.has(state.availableUtxos, hash)) {
            return yield* Either.left(new UtxoNotFoundError({ utxo: utxo.utxo }));
        }
        return {
            availableUtxos: HashMap.remove(state.availableUtxos, hash),
            pendingUtxos: HashMap.set(state.pendingUtxos, hash, utxo),
        };
    }),
    rollbackSpend: (state, utxo) => Either.gen(function* () {
        const hash = UtxoHash(utxo.utxo);
        if (!HashMap.has(state.pendingUtxos, hash)) {
            return yield* Either.left(new UtxoNotFoundError({ utxo: utxo.utxo }));
        }
        return {
            availableUtxos: HashMap.set(state.availableUtxos, hash, utxo),
            pendingUtxos: HashMap.remove(state.pendingUtxos, hash),
        };
    }),
    spendByUtxo: (state, utxo) => Either.gen(function* () {
        const hash = UtxoHash(utxo);
        const found = yield* Either.fromOption(HashMap.get(state.availableUtxos, hash), () => new UtxoNotFoundError({ utxo }));
        return yield* UnshieldedState.spend(state, found);
    }),
    rollbackSpendByUtxo: (state, utxo) => Either.gen(function* () {
        const hash = UtxoHash(utxo);
        const found = yield* Either.fromOption(HashMap.get(state.pendingUtxos, hash), () => new UtxoNotFoundError({ utxo }));
        return yield* UnshieldedState.rollbackSpend(state, found);
    }),
    applyUpdate: (state, update) => Either.gen(function* () {
        if (!['SUCCESS', 'PARTIAL_SUCCESS'].includes(update.status)) {
            return yield* Either.left(new ApplyTransactionError({ message: `Invalid status: ${update.status}` }));
        }
        return {
            availableUtxos: HashMap.union(HashMap.removeMany(state.availableUtxos, update.spentUtxos.map((utxo) => UtxoHash(utxo.utxo))), HashMap.fromIterable(update.createdUtxos.map((utxo) => [UtxoHash(utxo.utxo), utxo]))),
            pendingUtxos: HashMap.removeMany(state.pendingUtxos, update.spentUtxos.map((utxo) => UtxoHash(utxo.utxo))),
        };
    }),
    applyFailedUpdate: (state, update) => Either.gen(function* () {
        if (update.status !== 'FAILURE') {
            return yield* Either.left(new ApplyTransactionError({ message: `Invalid status: ${update.status}` }));
        }
        return {
            availableUtxos: HashMap.union(state.availableUtxos, HashMap.fromIterable(update.spentUtxos.map((utxo) => [UtxoHash(utxo.utxo), utxo]))),
            pendingUtxos: HashMap.removeMany(state.pendingUtxos, update.spentUtxos.map((utxo) => UtxoHash(utxo.utxo))),
        };
    }),
    toArrays: (state) => ({
        availableUtxos: HashMap.toValues(state.availableUtxos),
        pendingUtxos: HashMap.toValues(state.pendingUtxos),
    }),
};
