import * as ledger from '@midnight-ntwrk/ledger-v7';
import { Data, Either, HashMap } from 'effect';
import { ApplyTransactionError, UtxoNotFoundError } from './WalletError.js';
export interface UtxoMeta {
    readonly ctime: Date;
    readonly registeredForDustGeneration: boolean;
}
export type UtxoHash = string;
export declare class UtxoWithMeta extends Data.Class<{
    readonly utxo: ledger.Utxo;
    readonly meta: UtxoMeta;
}> {
}
export type UpdateStatus = 'SUCCESS' | 'FAILURE' | 'PARTIAL_SUCCESS';
export interface UnshieldedUpdate {
    readonly createdUtxos: readonly UtxoWithMeta[];
    readonly spentUtxos: readonly UtxoWithMeta[];
    readonly status: UpdateStatus;
}
export interface UnshieldedState {
    readonly availableUtxos: HashMap.HashMap<UtxoHash, UtxoWithMeta>;
    readonly pendingUtxos: HashMap.HashMap<UtxoHash, UtxoWithMeta>;
}
export declare const UnshieldedState: {
    readonly empty: () => UnshieldedState;
    readonly restore: (availableUtxos: readonly UtxoWithMeta[], pendingUtxos: readonly UtxoWithMeta[]) => UnshieldedState;
    readonly spend: (state: UnshieldedState, utxo: UtxoWithMeta) => Either.Either<UnshieldedState, UtxoNotFoundError>;
    readonly rollbackSpend: (state: UnshieldedState, utxo: UtxoWithMeta) => Either.Either<UnshieldedState, UtxoNotFoundError>;
    readonly spendByUtxo: (state: UnshieldedState, utxo: ledger.Utxo) => Either.Either<UnshieldedState, UtxoNotFoundError>;
    readonly rollbackSpendByUtxo: (state: UnshieldedState, utxo: ledger.Utxo) => Either.Either<UnshieldedState, UtxoNotFoundError>;
    readonly applyUpdate: (state: UnshieldedState, update: UnshieldedUpdate) => Either.Either<UnshieldedState, ApplyTransactionError>;
    readonly applyFailedUpdate: (state: UnshieldedState, update: UnshieldedUpdate) => Either.Either<UnshieldedState, ApplyTransactionError>;
    readonly toArrays: (state: UnshieldedState) => {
        readonly availableUtxos: readonly UtxoWithMeta[];
        readonly pendingUtxos: readonly UtxoWithMeta[];
    };
};
