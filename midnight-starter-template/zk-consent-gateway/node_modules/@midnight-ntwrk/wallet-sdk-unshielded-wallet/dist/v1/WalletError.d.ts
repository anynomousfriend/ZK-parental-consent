import * as ledger from '@midnight-ntwrk/ledger-v7';
export declare const WalletError: {
    other(err: unknown): WalletError;
};
export type WalletError = OtherWalletError | InsufficientFundsError | AddressError | SyncWalletError | TransactingError | SignError | ApplyTransactionError | RollbackUtxoError | SpendUtxoError;
declare const OtherWalletError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.Other";
} & Readonly<A>;
export declare class OtherWalletError extends OtherWalletError_base<{
    message: string;
    cause?: unknown;
}> {
}
declare const SyncWalletError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.Sync";
} & Readonly<A>;
export declare class SyncWalletError extends SyncWalletError_base<{
    message: string;
    cause?: unknown;
}> {
}
declare const InsufficientFundsError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.InsufficientFunds";
} & Readonly<A>;
export declare class InsufficientFundsError extends InsufficientFundsError_base<{
    message: string;
    tokenType: ledger.RawTokenType;
    amount: bigint;
}> {
}
declare const AddressError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.Address";
} & Readonly<A>;
export declare class AddressError extends AddressError_base<{
    message: string;
    originalAddress: string;
    cause?: unknown;
}> {
}
declare const TransactingError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.Transacting";
} & Readonly<A>;
export declare class TransactingError extends TransactingError_base<{
    message: string;
    cause?: unknown;
}> {
}
declare const SignError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.Sign";
} & Readonly<A>;
export declare class SignError extends SignError_base<{
    message: string;
    cause?: unknown;
}> {
}
declare const ApplyTransactionError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.ApplyTransaction";
} & Readonly<A>;
export declare class ApplyTransactionError extends ApplyTransactionError_base<{
    message: string;
    cause?: unknown;
}> {
}
declare const RollbackUtxoError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.RollbackUtxo";
} & Readonly<A>;
export declare class RollbackUtxoError extends RollbackUtxoError_base<{
    message: string;
    utxo: ledger.Utxo;
    cause?: unknown;
}> {
}
declare const SpendUtxoError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.SpendUtxo";
} & Readonly<A>;
export declare class SpendUtxoError extends SpendUtxoError_base<{
    message: string;
    utxo: ledger.Utxo;
    cause?: unknown;
}> {
}
declare const UtxoNotFoundError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "UtxoNotFoundError";
} & Readonly<A>;
export declare class UtxoNotFoundError extends UtxoNotFoundError_base<{
    readonly utxo: ledger.Utxo;
}> {
}
export {};
