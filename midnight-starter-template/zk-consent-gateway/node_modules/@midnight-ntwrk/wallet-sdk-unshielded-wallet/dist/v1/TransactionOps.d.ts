import { Either } from 'effect';
import { Imbalances } from '@midnight-ntwrk/wallet-sdk-capabilities';
import * as ledger from '@midnight-ntwrk/ledger-v7';
import { WalletError } from './WalletError.js';
/**
 * Unbound transaction type. This is a transaction that has no signatures and is not bound yet.
 */
export type UnboundTransaction = ledger.Transaction<ledger.SignatureEnabled, ledger.Proof, ledger.PreBinding>;
/**
 * Utility type to extract the Intent type from a Transaction type.
 * Maps Transaction<S, P, B> to Intent<S, P, B>.
 */
export type IntentOf<T> = T extends ledger.Transaction<infer S, infer P, infer B> ? ledger.Intent<S, P, B> : never;
export type TransactionOps = {
    getSignatureData: (transaction: ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.PreBinding>, segment: number) => Either.Either<Uint8Array, WalletError>;
    getSegments(transaction: ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>): number[];
    addSignature(transaction: ledger.UnprovenTransaction | UnboundTransaction, signature: ledger.Signature, segment: number): Either.Either<ledger.UnprovenTransaction, WalletError>;
    getImbalances(transaction: ledger.FinalizedTransaction | UnboundTransaction | ledger.UnprovenTransaction, segment: number): Imbalances;
    addSignaturesToOffer(offer: ledger.UnshieldedOffer<ledger.SignatureEnabled>, signature: ledger.Signature, segment: number, offerType: 'guaranteed' | 'fallible'): Either.Either<ledger.UnshieldedOffer<ledger.SignatureEnabled>, WalletError>;
    isIntentBound(intent: ledger.Intent<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>): boolean;
    extractOwnInputs(transaction: ledger.FinalizedTransaction | UnboundTransaction | ledger.UnprovenTransaction, signatureVerifyingKey: ledger.SignatureVerifyingKey): ledger.Utxo[];
};
export declare const TransactionOps: TransactionOps;
