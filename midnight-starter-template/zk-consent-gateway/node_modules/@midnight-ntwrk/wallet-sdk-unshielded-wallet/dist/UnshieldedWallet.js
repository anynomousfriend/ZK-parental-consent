// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { V1Builder, V1Tag, CoreWallet, } from './v1/index.js';
import { Effect, Either } from 'effect';
import * as rx from 'rxjs';
import { WalletBuilder } from '@midnight-ntwrk/wallet-sdk-runtime';
export class UnshieldedWalletState {
    static mapState = (capabilities) => (state) => {
        return new UnshieldedWalletState(state, capabilities);
    };
    protocolVersion;
    state;
    capabilities;
    get balances() {
        return this.capabilities.coinsAndBalances.getAvailableBalances(this.state);
    }
    get totalCoins() {
        return this.capabilities.coinsAndBalances.getTotalCoins(this.state);
    }
    get availableCoins() {
        return this.capabilities.coinsAndBalances.getAvailableCoins(this.state);
    }
    get pendingCoins() {
        return this.capabilities.coinsAndBalances.getPendingCoins(this.state);
    }
    get address() {
        return this.capabilities.keys.getAddress(this.state);
    }
    get progress() {
        return this.state.progress;
    }
    get transactionHistory() {
        return this.capabilities.transactionHistory;
    }
    constructor(state, capabilities) {
        this.protocolVersion = state.version;
        this.state = state.state;
        this.capabilities = capabilities;
    }
    serialize() {
        return this.capabilities.serialization.serialize(this.state);
    }
}
export function UnshieldedWallet(configuration) {
    return CustomUnshieldedWallet(configuration, new V1Builder().withDefaults());
}
export function CustomUnshieldedWallet(configuration, builder) {
    const buildArgs = [configuration];
    const BaseWallet = WalletBuilder.init()
        .withVariant(ProtocolVersion.MinSupportedVersion, builder)
        .build(...buildArgs);
    return class CustomUnshieldedWalletImplementation extends BaseWallet {
        static startWithPublicKey(publicKeys) {
            return CustomUnshieldedWalletImplementation.startFirst(CustomUnshieldedWalletImplementation, CoreWallet.init(publicKeys, configuration.networkId));
        }
        static restore(serializedState) {
            const deserialized = CustomUnshieldedWalletImplementation.allVariantsRecord()[V1Tag].variant.deserializeState(serializedState)
                .pipe(Either.getOrThrow);
            return CustomUnshieldedWalletImplementation.startFirst(CustomUnshieldedWalletImplementation, deserialized);
        }
        state;
        constructor(runtime, scope) {
            super(runtime, scope);
            this.state = this.rawState.pipe(rx.map(UnshieldedWalletState.mapState(CustomUnshieldedWalletImplementation.allVariantsRecord()[V1Tag].variant)), rx.shareReplay({ refCount: true, bufferSize: 1 }));
        }
        start() {
            return this.runtime.dispatch({ [V1Tag]: (v1) => v1.startSyncInBackground() }).pipe(Effect.runPromise);
        }
        balanceFinalizedTransaction(tx) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.balanceFinalizedTransaction(tx),
            })
                .pipe(Effect.runPromise);
        }
        balanceUnboundTransaction(tx) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.balanceUnboundTransaction(tx),
            })
                .pipe(Effect.runPromise);
        }
        balanceUnprovenTransaction(tx) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.balanceUnprovenTransaction(tx),
            })
                .pipe(Effect.runPromise);
        }
        transferTransaction(outputs, ttl) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.transferTransaction(outputs, ttl),
            })
                .pipe(Effect.runPromise);
        }
        initSwap(desiredInputs, desiredOutputs, ttl) {
            return this.runtime
                .dispatch({ [V1Tag]: (v1) => v1.initSwap(desiredInputs, desiredOutputs, ttl) })
                .pipe(Effect.runPromise);
        }
        signUnprovenTransaction(transaction, signSegment) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.signUnprovenTransaction(transaction, signSegment),
            })
                .pipe(Effect.runPromise);
        }
        signUnboundTransaction(transaction, signSegment) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.signUnboundTransaction(transaction, signSegment),
            })
                .pipe(Effect.runPromise);
        }
        waitForSyncedState(allowedGap = 0n) {
            return rx.firstValueFrom(this.state.pipe(rx.filter((state) => state.state.progress.isCompleteWithin(allowedGap))));
        }
        /**
         * Serializes the most recent state
         * It's preferable to use [[UnshieldedWalletState.serialize]] instead, to know exactly, which state is serialized
         */
        serializeState() {
            return rx.firstValueFrom(this.state).then((state) => state.serialize());
        }
        getAddress() {
            return rx.firstValueFrom(this.state).then((state) => state.address);
        }
    };
}
