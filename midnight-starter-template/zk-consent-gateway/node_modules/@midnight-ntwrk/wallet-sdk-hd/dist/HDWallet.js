// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { HDKey } from '@scure/bip32';
export const Roles = {
    NightExternal: 0,
    NightInternal: 1,
    Dust: 2,
    Zswap: 3,
    Metadata: 4,
};
const PURPOSE = 44;
const COIN_TYPE = 2400;
const CompositeDerivationResult = {
    fromResults: (results) => {
        const { succeededKeys, failedRoles } = results.reduce((acc, result) => {
            if (result.result.type === 'keyDerived') {
                acc.succeededKeys[result.role] = result.result.key;
            }
            else {
                acc.failedRoles.push(result.role);
            }
            return acc;
        }, { succeededKeys: {}, failedRoles: [] });
        if (failedRoles.length > 0) {
            return { type: 'keyOutOfBounds', roles: failedRoles };
        }
        else {
            return { type: 'keysDerived', keys: succeededKeys };
        }
    },
};
export class HDWallet {
    rootKey;
    constructor(key) {
        this.rootKey = key;
    }
    static fromSeed(seed) {
        try {
            const rootKey = HDKey.fromMasterSeed(seed);
            return { type: 'seedOk', hdWallet: new HDWallet(rootKey) };
        }
        catch (e) {
            return { type: 'seedError', error: e };
        }
    }
    // Begin by selecting an account.
    selectAccount(account) {
        return new AccountKey(this.rootKey, account);
    }
    /**
     * Once all keys are derived - clear internals from private data, so that they do not reside in memory longer than needed.
     */
    clear() {
        this.rootKey.wipePrivateData();
    }
}
export class AccountKey {
    rootKey;
    account;
    constructor(rootKey, account) {
        this.account = account;
        this.rootKey = rootKey;
    }
    // After account, select a role.
    selectRole(role) {
        return new RoleKey(this.rootKey, this.account, role);
    }
    selectRoles(roles) {
        return new CompositeRoleKey(this.rootKey, this.account, roles);
    }
}
export class RoleKey {
    rootKey;
    account;
    role;
    constructor(rootKey, account, role) {
        this.role = role;
        this.account = account;
        this.rootKey = rootKey;
    }
    // Finally, derive the key at the given index.
    deriveKeyAt(index) {
        const path = `m/${PURPOSE}'/${COIN_TYPE}'/${this.account}'/${this.role}/${index}`;
        const derivedKey = this.rootKey.derive(path);
        return derivedKey.privateKey ? { type: 'keyDerived', key: derivedKey.privateKey } : { type: 'keyOutOfBounds' };
    }
}
export class CompositeRoleKey {
    rootKey;
    account;
    roles;
    constructor(rootKey, account, roles) {
        this.roles = roles;
        this.rootKey = rootKey;
        this.account = account;
    }
    deriveKeysAt(index) {
        const results = this.roles.map((role) => ({
            role,
            result: new RoleKey(this.rootKey, this.account, role).deriveKeyAt(index),
        }));
        return CompositeDerivationResult.fromResults(results);
    }
}
