import { HDKey } from '@scure/bip32';
type ValueOf<T> = T[keyof T];
export declare const Roles: {
    readonly NightExternal: 0;
    readonly NightInternal: 1;
    readonly Dust: 2;
    readonly Zswap: 3;
    readonly Metadata: 4;
};
export type Role = ValueOf<typeof Roles>;
type DerivationResult = {
    readonly type: 'keyDerived';
    readonly key: Uint8Array;
} | {
    readonly type: 'keyOutOfBounds';
};
type CompositeDerivationResult<T extends readonly Role[]> = {
    readonly type: 'keysDerived';
    readonly keys: Record<T[number], Uint8Array>;
} | {
    readonly type: 'keyOutOfBounds';
    readonly roles: readonly Role[];
};
type HDWalletResult = {
    readonly type: 'seedOk';
    readonly hdWallet: HDWallet;
} | {
    readonly type: 'seedError';
    readonly error: unknown;
};
declare const CompositeDerivationResult: {
    fromResults: <T extends readonly Role[]>(results: {
        role: T[number];
        result: DerivationResult;
    }[]) => CompositeDerivationResult<T>;
};
export declare class HDWallet {
    private readonly rootKey;
    private constructor();
    static fromSeed(seed: Uint8Array): HDWalletResult;
    selectAccount(account: number): AccountKey;
    /**
     * Once all keys are derived - clear internals from private data, so that they do not reside in memory longer than needed.
     */
    clear(): void;
}
export declare class AccountKey {
    private readonly rootKey;
    private readonly account;
    constructor(rootKey: HDKey, account: number);
    selectRole(role: Role): RoleKey;
    selectRoles<T extends readonly Role[]>(roles: T): CompositeRoleKey<T>;
}
export declare class RoleKey {
    private readonly rootKey;
    private readonly account;
    private readonly role;
    constructor(rootKey: HDKey, account: number, role: Role);
    deriveKeyAt(index: number): DerivationResult;
}
export declare class CompositeRoleKey<T extends readonly Role[]> {
    private readonly rootKey;
    private readonly account;
    private readonly roles;
    constructor(rootKey: HDKey, account: number, roles: T);
    deriveKeysAt(index: number): CompositeDerivationResult<T>;
}
export {};
