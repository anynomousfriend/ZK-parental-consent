export type TokenType = string;
export type TokenValue = bigint;
export interface CoinRecipe {
    type: TokenType;
    value: TokenValue;
}
export type Imbalance = [TokenType, TokenValue];
export type Imbalances = Map<TokenType, TokenValue>;
export declare const Imbalances: {
    empty: () => Imbalances;
    fromEntry: (tokenType: TokenType, value: bigint) => Imbalances;
    fromEntries: (entries: Iterable<readonly [TokenType, bigint]>) => Imbalances;
    fromMap: (map: Map<TokenType, bigint>) => Imbalances;
    fromMaybeMap: (map: Map<TokenType, bigint> | undefined) => Imbalances;
    getValue: (map: Imbalances, tokenType: TokenType) => bigint;
    typeSet: (map: Imbalances) => Set<TokenType>;
    ensureZerosFor(map: Imbalances, types: Iterable<TokenType>): Imbalances;
    merge: (a: Imbalances, b: Imbalances) => Imbalances;
};
