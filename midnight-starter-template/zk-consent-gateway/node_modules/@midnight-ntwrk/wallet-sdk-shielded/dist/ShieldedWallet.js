// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { V1Builder, V1Tag, CoreWallet } from './v1/index.js';
import * as ledger from '@midnight-ntwrk/ledger-v7';
import { Effect, Either } from 'effect';
import * as rx from 'rxjs';
import { WalletBuilder } from '@midnight-ntwrk/wallet-sdk-runtime';
export class ShieldedWalletState {
    static mapState = (capabilities) => (state) => {
        return new ShieldedWalletState(state, capabilities);
    };
    protocolVersion;
    state;
    capabilities;
    get balances() {
        return this.capabilities.coinsAndBalances.getAvailableBalances(this.state);
    }
    get totalCoins() {
        return this.capabilities.coinsAndBalances.getTotalCoins(this.state);
    }
    get availableCoins() {
        return this.capabilities.coinsAndBalances.getAvailableCoins(this.state);
    }
    get pendingCoins() {
        return this.capabilities.coinsAndBalances.getPendingCoins(this.state);
    }
    get coinPublicKey() {
        return this.capabilities.keys.getCoinPublicKey(this.state);
    }
    get encryptionPublicKey() {
        return this.capabilities.keys.getEncryptionPublicKey(this.state);
    }
    get address() {
        return this.capabilities.keys.getAddress(this.state);
    }
    get progress() {
        return this.capabilities.transactionHistory.progress(this.state);
    }
    get transactionHistory() {
        return this.capabilities.transactionHistory.transactionHistory(this.state);
    }
    constructor(state, capabilities) {
        this.protocolVersion = state.version;
        this.state = state.state;
        this.capabilities = capabilities;
    }
    serialize() {
        return this.capabilities.serialization.serialize(this.state);
    }
}
export function ShieldedWallet(configuration) {
    return CustomShieldedWallet(configuration, new V1Builder().withDefaults());
}
export function CustomShieldedWallet(configuration, builder) {
    const buildArgs = [configuration];
    const BaseWallet = WalletBuilder.init()
        .withVariant(ProtocolVersion.MinSupportedVersion, builder)
        .build(...buildArgs);
    return class CustomShieldedWalletImplementation extends BaseWallet {
        static startWithSecretKeys(secretKeys) {
            return CustomShieldedWalletImplementation.startFirst(CustomShieldedWalletImplementation, CoreWallet.initEmpty(secretKeys, CustomShieldedWalletImplementation.configuration.networkId));
        }
        static startWithShieldedSeed(seed) {
            const secretKeys = ledger.ZswapSecretKeys.fromSeed(seed);
            return CustomShieldedWalletImplementation.startWithSecretKeys(secretKeys);
        }
        static restore(serializedState) {
            const deserialized = CustomShieldedWalletImplementation.allVariantsRecord()[V1Tag].variant.deserializeState(serializedState)
                .pipe(Either.getOrThrow);
            return CustomShieldedWalletImplementation.startFirst(CustomShieldedWalletImplementation, deserialized);
        }
        state;
        constructor(runtime, scope) {
            super(runtime, scope);
            this.state = this.rawState.pipe(rx.map(ShieldedWalletState.mapState(CustomShieldedWalletImplementation.allVariantsRecord()[V1Tag].variant)), rx.shareReplay({ refCount: true, bufferSize: 1 }));
        }
        start(secretKeys) {
            return this.runtime.dispatch({ [V1Tag]: (v1) => v1.startSyncInBackground(secretKeys) }).pipe(Effect.runPromise);
        }
        balanceTransaction(secretKeys, tx) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.balanceTransaction(secretKeys, tx),
            })
                .pipe(Effect.runPromise);
        }
        transferTransaction(secretKeys, outputs) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.transferTransaction(secretKeys, outputs),
            })
                .pipe(Effect.runPromise);
        }
        initSwap(secretKeys, desiredInputs, desiredOutputs) {
            return this.runtime
                .dispatch({ [V1Tag]: (v1) => v1.initSwap(secretKeys, desiredInputs, desiredOutputs) })
                .pipe(Effect.runPromise);
        }
        finalizeTransaction(transaction) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.finalizeTransaction(transaction),
            })
                .pipe(Effect.runPromise);
        }
        submitTransaction = ((tx, waitForStatus = 'InBlock') => {
            return this.runtime
                .dispatch({ [V1Tag]: (v1) => v1.submitTransaction(tx, waitForStatus) })
                .pipe(Effect.runPromise);
        });
        waitForSyncedState(allowedGap = 0n) {
            return rx.firstValueFrom(this.state.pipe(rx.filter((state) => state.state.progress.isCompleteWithin(allowedGap))));
        }
        /**
         * Serializes the most recent state
         * It's preferable to use [[ShieldedWalletState.serialize]] instead, to know exactly, which state is serialized
         */
        serializeState() {
            return rx.firstValueFrom(this.state).then((state) => state.serialize());
        }
        getAddress() {
            return rx.firstValueFrom(this.state).then((state) => state.address);
        }
    };
}
