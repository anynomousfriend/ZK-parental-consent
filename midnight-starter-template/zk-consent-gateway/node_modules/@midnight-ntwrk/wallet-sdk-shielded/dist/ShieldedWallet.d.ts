import { ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { BaseV1Configuration, DefaultV1Configuration, V1Variant, CoreWallet } from './v1/index.js';
import * as ledger from '@midnight-ntwrk/ledger-v7';
import * as rx from 'rxjs';
import { BalancingResult } from './v1/Transacting.js';
import { SerializationCapability } from './v1/Serialization.js';
import { ProgressUpdate, TransactionHistoryCapability } from './v1/TransactionHistory.js';
import { AvailableCoin, CoinsAndBalancesCapability, PendingCoin } from './v1/CoinsAndBalances.js';
import { KeysCapability } from './v1/Keys.js';
import { ShieldedAddress, ShieldedCoinPublicKey, ShieldedEncryptionPublicKey } from '@midnight-ntwrk/wallet-sdk-address-format';
import { SubmissionEvent, SubmissionEventCases } from './v1/Submission.js';
import { TokenTransfer } from './v1/Transacting.js';
import { WalletSyncUpdate } from './v1/Sync.js';
import { Variant, VariantBuilder, WalletLike } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
export type ShieldedWalletCapabilities<TSerialized = string, TTransaction = ledger.FinalizedTransaction> = {
    serialization: SerializationCapability<CoreWallet, null, TSerialized>;
    coinsAndBalances: CoinsAndBalancesCapability<CoreWallet>;
    keys: KeysCapability<CoreWallet>;
    transactionHistory: TransactionHistoryCapability<CoreWallet, TTransaction>;
};
export type UnboundTransaction = ledger.Transaction<ledger.SignatureEnabled, ledger.Proof, ledger.PreBinding>;
export declare class ShieldedWalletState<TSerialized = string, TTransaction = ledger.FinalizedTransaction> {
    static readonly mapState: <TSerialized_1 = string, TTransaction_1 = ledger.FinalizedTransaction>(capabilities: ShieldedWalletCapabilities<TSerialized_1, TTransaction_1>) => (state: ProtocolState.ProtocolState<CoreWallet>) => ShieldedWalletState<TSerialized_1, TTransaction_1>;
    readonly protocolVersion: ProtocolVersion.ProtocolVersion;
    readonly state: CoreWallet;
    readonly capabilities: ShieldedWalletCapabilities<TSerialized, TTransaction>;
    get balances(): Record<ledger.RawTokenType, bigint>;
    get totalCoins(): readonly (AvailableCoin | PendingCoin)[];
    get availableCoins(): readonly AvailableCoin[];
    get pendingCoins(): readonly PendingCoin[];
    get coinPublicKey(): ShieldedCoinPublicKey;
    get encryptionPublicKey(): ShieldedEncryptionPublicKey;
    get address(): ShieldedAddress;
    get progress(): ProgressUpdate;
    get transactionHistory(): readonly TTransaction[];
    constructor(state: ProtocolState.ProtocolState<CoreWallet>, capabilities: ShieldedWalletCapabilities<TSerialized, TTransaction>);
    serialize(): TSerialized;
}
export type SubmitTransactionMethod<TTransaction> = {
    (transaction: TTransaction, waitForStatus: 'Submitted'): Promise<SubmissionEventCases.Submitted>;
    (transaction: TTransaction, waitForStatus: 'InBlock'): Promise<SubmissionEventCases.InBlock>;
    (transaction: TTransaction, waitForStatus: 'Finalized'): Promise<SubmissionEventCases.Finalized>;
    (transaction: TTransaction): Promise<SubmissionEventCases.InBlock>;
    (transaction: TTransaction, waitForStatus?: 'Submitted' | 'InBlock' | 'Finalized'): Promise<SubmissionEvent>;
};
export type ShieldedWallet = CustomizedShieldedWallet<ledger.ZswapSecretKeys, ledger.FinalizedTransaction, WalletSyncUpdate, string>;
export type ShieldedWalletClass = CustomizedShieldedWalletClass<ledger.ZswapSecretKeys, ledger.FinalizedTransaction, WalletSyncUpdate, string>;
export interface CustomizedShieldedWallet<TStartAux = ledger.ZswapSecretKeys, TTransaction = ledger.FinalizedTransaction, TSyncUpdate = WalletSyncUpdate, TSerialized = string> extends WalletLike.WalletLike<[
    Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>>
]> {
    readonly state: rx.Observable<ShieldedWalletState<TSerialized, TTransaction>>;
    start(secretKeys: TStartAux): Promise<void>;
    balanceTransaction(secretKeys: ledger.ZswapSecretKeys, tx: ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>): Promise<BalancingResult>;
    transferTransaction(secretKeys: ledger.ZswapSecretKeys, outputs: readonly TokenTransfer[]): Promise<ledger.UnprovenTransaction>;
    initSwap(secretKeys: ledger.ZswapSecretKeys, desiredInputs: Record<ledger.RawTokenType, bigint>, desiredOutputs: readonly TokenTransfer[]): Promise<ledger.UnprovenTransaction>;
    finalizeTransaction(transaction: ledger.UnprovenTransaction): Promise<TTransaction>;
    readonly submitTransaction: SubmitTransactionMethod<TTransaction>;
    serializeState(): Promise<TSerialized>;
    waitForSyncedState(allowedGap?: bigint): Promise<ShieldedWalletState<TSerialized, TTransaction>>;
    getAddress(): Promise<ShieldedAddress>;
}
export interface CustomizedShieldedWalletClass<TStartAux = ledger.ZswapSecretKeys, TTransaction = ledger.FinalizedTransaction, TSyncUpdate = WalletSyncUpdate, TSerialized = string, TConfig extends BaseV1Configuration = DefaultV1Configuration> extends WalletLike.BaseWalletClass<[
    Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>>
]> {
    configuration: TConfig;
    startWithShieldedSeed(seed: Uint8Array): CustomizedShieldedWallet<TStartAux, TTransaction, TSyncUpdate, TSerialized>;
    startWithSecretKeys(secretKeys: ledger.ZswapSecretKeys): CustomizedShieldedWallet<TStartAux, TTransaction, TSyncUpdate, TSerialized>;
    restore(serializedState: TSerialized): CustomizedShieldedWallet<TStartAux, TTransaction, TSyncUpdate, TSerialized>;
}
export declare function ShieldedWallet(configuration: DefaultV1Configuration): ShieldedWalletClass;
export declare function CustomShieldedWallet<TConfig extends BaseV1Configuration = DefaultV1Configuration, TStartAux = ledger.ZswapSecretKeys, TTransaction = ledger.FinalizedTransaction, TSyncUpdate = WalletSyncUpdate, TSerialized = string>(configuration: TConfig, builder: VariantBuilder.VariantBuilder<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>, TConfig>): CustomizedShieldedWalletClass<TStartAux, TTransaction, TSyncUpdate, TSerialized, TConfig>;
