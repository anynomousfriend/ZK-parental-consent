import * as ledger from '@midnight-ntwrk/ledger-v7';
import { LedgerOps } from '@midnight-ntwrk/wallet-sdk-utilities';
export declare const WalletError: {
    proving(err: Error): WalletError;
    other(err: unknown): WalletError;
    submission(err: unknown): WalletError;
};
export type WalletError = ProvingError | OtherWalletError | InsufficientFundsError | SubmissionError | AddressError | SyncWalletError | InvalidCoinHashesError | TransactingError | LedgerOps.LedgerError;
declare const ProvingError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.Proving";
} & Readonly<A>;
export declare class ProvingError extends ProvingError_base<{
    message: string;
    cause: Error;
}> {
}
declare const OtherWalletError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.Other";
} & Readonly<A>;
export declare class OtherWalletError extends OtherWalletError_base<{
    message: string;
    cause?: unknown;
}> {
}
declare const SyncWalletError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.Sync";
} & Readonly<A>;
export declare class SyncWalletError extends SyncWalletError_base<{
    message: string;
    cause?: unknown;
}> {
}
declare const SubmissionError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.SubmissionWalletError";
} & Readonly<A>;
export declare class SubmissionError extends SubmissionError_base<{
    message: string;
    cause?: unknown;
}> {
}
declare const InsufficientFundsError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.InsufficientFunds";
} & Readonly<A>;
export declare class InsufficientFundsError extends InsufficientFundsError_base<{
    message: string;
    tokenType: ledger.RawTokenType;
    amount: bigint;
}> {
}
declare const AddressError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.Address";
} & Readonly<A>;
export declare class AddressError extends AddressError_base<{
    message: string;
    originalAddress: string;
    cause?: unknown;
}> {
}
declare const InvalidCoinHashesError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.InvalidCoinHashes";
} & Readonly<A>;
export declare class InvalidCoinHashesError extends InvalidCoinHashesError_base<{
    message: string;
    missingNonces: Set<ledger.Nonce>;
}> {
}
declare const TransactingError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "Wallet.Transacting";
} & Readonly<A>;
export declare class TransactingError extends TransactingError_base<{
    message: string;
    cause?: unknown;
}> {
}
export {};
