// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v7';
import { Chunk, Duration, Effect, Either, ParseResult, pipe, Schedule, Schema, Stream } from 'effect';
import { CoreWallet } from './CoreWallet.js';
import { ZswapEvents } from '@midnight-ntwrk/wallet-sdk-indexer-client';
import { ConnectionHelper, WsSubscriptionClient } from '@midnight-ntwrk/wallet-sdk-indexer-client/effect';
import { SyncWalletError } from './WalletError.js';
import { WsURL } from '@midnight-ntwrk/wallet-sdk-utilities/networking';
import { EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';
const Uint8ArraySchema = Schema.declare((input) => input instanceof Uint8Array).annotations({
    identifier: 'Uint8Array',
});
export const SecretKeysResource = {
    create: (secretKeys) => {
        /**
         * TODO: future Ledger version will include `clear` function to clear the secret keys,
         * it is intentend to be used here instead of `null`
         */
        let sk = secretKeys;
        return (cb) => {
            if (sk === null) {
                throw new Error('Secret keys have been consumed');
            }
            const result = cb(sk);
            sk = null;
            return result;
        };
    },
};
export const WalletSyncUpdate = {
    create: (updates, secretKeys) => {
        return {
            updates,
            secretKeys: SecretKeysResource.create(secretKeys),
        };
    },
};
const LedgerEventSchema = Schema.declare((input) => input instanceof ledger.Event).annotations({
    identifier: 'ledger.Event',
});
const LedgerEventFromUint8Array = Schema.transformOrFail(Uint8ArraySchema, LedgerEventSchema, {
    encode: (event) => Effect.try({
        try: () => event.serialize(),
        catch: (error) => new ParseResult.Unexpected(error, 'Could not serialize ledger event'),
    }),
    decode: (bytes) => Effect.try({
        try: () => ledger.Event.deserialize(bytes),
        catch: (error) => new ParseResult.Unexpected(error, 'Could not deserialize ledger event'),
    }),
});
const HexedLedgerEvent = pipe(Schema.Uint8ArrayFromHex, Schema.compose(LedgerEventFromUint8Array));
const EventsSyncUpdatePayload = Schema.Struct({
    id: Schema.Number,
    raw: Schema.String,
    maxId: Schema.Number,
});
export const EventsSyncUpdate = Schema.TaggedStruct('EventsSyncUpdate', {
    id: Schema.Number,
    maxId: Schema.Number,
    event: LedgerEventSchema,
});
const EventsSyncUpdateFromPayload = Schema.transformOrFail(EventsSyncUpdatePayload, EventsSyncUpdate, {
    decode: (input) => pipe(Schema.decodeUnknownEither(HexedLedgerEvent)(input.raw), Either.map((event) => ({
        _tag: 'EventsSyncUpdate',
        id: input.id,
        maxId: input.maxId,
        event,
    })), Either.mapLeft((error) => new ParseResult.Unexpected(error, 'Failed to decode ledger event payload')), EitherOps.toEffect),
    encode: (output) => pipe(Schema.encodeEither(HexedLedgerEvent)(output.event), Either.map((raw) => ({
        id: output.id,
        raw,
        maxId: output.maxId,
    })), Either.mapLeft((error) => new ParseResult.Unexpected(error, 'Failed to encode ledger event payload')), EitherOps.toEffect),
});
export const makeEventsSyncService = (config) => {
    return {
        updates: (state, secretKeys) => {
            const { indexerClientConnection } = config;
            const webSocketUrlResult = ConnectionHelper.createWebSocketUrl(indexerClientConnection.indexerHttpUrl, indexerClientConnection.indexerWsUrl);
            if (Either.isLeft(webSocketUrlResult)) {
                return Stream.fail(new SyncWalletError(new Error(`Could not derive WebSocket URL from indexer HTTP URL: ${webSocketUrlResult.left.message}`)));
            }
            const indexerWsUrlResult = WsURL.make(webSocketUrlResult.right);
            if (Either.isLeft(indexerWsUrlResult)) {
                return Stream.fail(new SyncWalletError(new Error(`Invalid indexer WS URL: ${indexerWsUrlResult.left.message}`)));
            }
            const indexerWsUrl = indexerWsUrlResult.right;
            const appliedIndex = state.progress?.appliedIndex ?? 0n;
            const batchSize = config.batchSize ?? 10;
            return pipe(ZswapEvents.run({ id: Number(appliedIndex) }), Stream.provideLayer(WsSubscriptionClient.layer({ url: indexerWsUrl })), Stream.mapError((error) => new SyncWalletError(error)), Stream.mapEffect((subscription) => pipe(subscription.zswapLedgerEvents, Schema.decodeUnknownEither(EventsSyncUpdateFromPayload), Either.mapLeft((err) => new SyncWalletError(err)), EitherOps.toEffect)), Stream.groupedWithin(batchSize, Duration.millis(1)), Stream.map(Chunk.toArray), Stream.map((data) => WalletSyncUpdate.create(data, secretKeys)), Stream.schedule(Schedule.spaced(Duration.millis(4))));
        },
    };
};
export const makeEventsSyncCapability = () => {
    return {
        applyUpdate: (state, wrappedUpdate) => {
            if (wrappedUpdate.updates.length === 0) {
                return state;
            }
            const lastUpdate = wrappedUpdate.updates.at(-1);
            const nextIndex = BigInt(lastUpdate.id);
            const highestRelevantWalletIndex = BigInt(lastUpdate.maxId);
            // in case the nextIndex is less than or equal to the appliedIndex
            // just update highestRelevantWalletIndex
            if (nextIndex <= state.progress.appliedIndex) {
                return CoreWallet.updateProgress(state, {
                    highestRelevantWalletIndex,
                    isConnected: true,
                });
            }
            return wrappedUpdate.secretKeys((keys) => {
                return CoreWallet.updateProgress(CoreWallet.replayEvents(state, keys, wrappedUpdate.updates.map((u) => u.event)), {
                    highestRelevantWalletIndex,
                    appliedIndex: nextIndex,
                    isConnected: true,
                });
            });
        },
    };
};
export const makeSimulatorSyncService = (config) => {
    return {
        updates: (_state, secretKeys) => config.simulator.state$.pipe(Stream.map((state) => ({ update: state, secretKeys: secretKeys }))),
    };
};
export const makeSimulatorSyncCapability = () => {
    return {
        applyUpdate: (state, update) => {
            const { update: { lastTxResult: { events }, }, secretKeys, } = update;
            return CoreWallet.replayEvents(state, secretKeys, events);
        },
    };
};
