import { Observable } from 'rxjs';
import { ShieldedWalletState, type ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import { type UnshieldedWallet, UnshieldedWalletState } from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { AnyTransaction, DustWallet, DustWalletState, CoinsAndBalances as DustCoinsAndBalances } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import * as ledger from '@midnight-ntwrk/ledger-v7';
export type UnboundTransaction = ledger.Transaction<ledger.SignatureEnabled, ledger.Proof, ledger.PreBinding>;
type TokenKind = 'dust' | 'shielded' | 'unshielded';
type TokenKindsToBalance = 'all' | TokenKind[];
declare const TokenKindsToBalance: {
    allTokenKinds: string[];
    toFlags: (tokenKinds: TokenKindsToBalance) => {
        shouldBalanceUnshielded: boolean;
        shouldBalanceShielded: boolean;
        shouldBalanceDust: boolean;
    };
};
export type FinalizedTransactionRecipe = {
    type: 'FINALIZED_TRANSACTION';
    originalTransaction: ledger.FinalizedTransaction;
    balancingTransaction: ledger.UnprovenTransaction;
};
export type UnboundTransactionRecipe = {
    type: 'UNBOUND_TRANSACTION';
    baseTransaction: UnboundTransaction;
    balancingTransaction?: ledger.UnprovenTransaction | undefined;
};
export type UnprovenTransactionRecipe = {
    type: 'UNPROVEN_TRANSACTION';
    transaction: ledger.UnprovenTransaction;
};
export type BalancingRecipe = FinalizedTransactionRecipe | UnboundTransactionRecipe | UnprovenTransactionRecipe;
export interface TokenTransfer {
    type: ledger.RawTokenType;
    receiverAddress: string;
    amount: bigint;
}
export type CombinedTokenTransfer = {
    type: 'shielded' | 'unshielded';
    outputs: TokenTransfer[];
};
export type CombinedSwapInputs = {
    shielded?: Record<ledger.RawTokenType, bigint>;
    unshielded?: Record<ledger.RawTokenType, bigint>;
};
export type CombinedSwapOutputs = CombinedTokenTransfer;
export type TransactionIdentifier = string;
export type UtxoWithMeta = {
    utxo: ledger.Utxo;
    meta: {
        ctime: Date;
    };
};
export declare class FacadeState {
    readonly shielded: ShieldedWalletState;
    readonly unshielded: UnshieldedWalletState;
    readonly dust: DustWalletState;
    get isSynced(): boolean;
    constructor(shielded: ShieldedWalletState, unshielded: UnshieldedWalletState, dust: DustWalletState);
}
export declare class WalletFacade {
    readonly shielded: ShieldedWallet;
    readonly unshielded: UnshieldedWallet;
    readonly dust: DustWallet;
    constructor(shieldedWallet: ShieldedWallet, unshieldedWallet: UnshieldedWallet, dustWallet: DustWallet);
    private defaultTtl;
    private mergeUnprovenTransactions;
    private createDustActionTransaction;
    state(): Observable<FacadeState>;
    waitForSyncedState(): Promise<FacadeState>;
    submitTransaction(tx: ledger.FinalizedTransaction): Promise<TransactionIdentifier>;
    balanceFinalizedTransaction(tx: ledger.FinalizedTransaction, secretKeys: {
        shieldedSecretKeys: ledger.ZswapSecretKeys;
        dustSecretKey: ledger.DustSecretKey;
    }, options: {
        ttl: Date;
        tokenKindsToBalance?: TokenKindsToBalance;
    }): Promise<FinalizedTransactionRecipe>;
    balanceUnboundTransaction(tx: UnboundTransaction, secretKeys: {
        shieldedSecretKeys: ledger.ZswapSecretKeys;
        dustSecretKey: ledger.DustSecretKey;
    }, options: {
        ttl: Date;
        tokenKindsToBalance?: TokenKindsToBalance;
    }): Promise<UnboundTransactionRecipe>;
    balanceUnprovenTransaction(tx: ledger.UnprovenTransaction, secretKeys: {
        shieldedSecretKeys: ledger.ZswapSecretKeys;
        dustSecretKey: ledger.DustSecretKey;
    }, options: {
        ttl: Date;
        tokenKindsToBalance?: TokenKindsToBalance;
    }): Promise<UnprovenTransactionRecipe>;
    finalizeRecipe(recipe: BalancingRecipe): Promise<ledger.FinalizedTransaction>;
    signRecipe(recipe: BalancingRecipe, signSegment: (data: Uint8Array) => ledger.Signature): Promise<BalancingRecipe>;
    signUnprovenTransaction(tx: ledger.UnprovenTransaction, signSegment: (data: Uint8Array) => ledger.Signature): Promise<ledger.UnprovenTransaction>;
    signUnboundTransaction(tx: UnboundTransaction, signSegment: (data: Uint8Array) => ledger.Signature): Promise<UnboundTransaction>;
    finalizeTransaction(tx: ledger.UnprovenTransaction): Promise<ledger.FinalizedTransaction>;
    calculateTransactionFee(tx: AnyTransaction): Promise<bigint>;
    transferTransaction(outputs: CombinedTokenTransfer[], secretKeys: {
        shieldedSecretKeys: ledger.ZswapSecretKeys;
        dustSecretKey: ledger.DustSecretKey;
    }, options: {
        ttl: Date;
        payFees?: boolean;
    }): Promise<UnprovenTransactionRecipe>;
    estimateRegistration(nightUtxos: readonly UtxoWithMeta[]): Promise<{
        fee: bigint;
        dustGenerationEstimations: ReadonlyArray<DustCoinsAndBalances.UtxoWithFullDustDetails>;
    }>;
    initSwap(desiredInputs: CombinedSwapInputs, desiredOutputs: CombinedSwapOutputs[], secretKeys: {
        shieldedSecretKeys: ledger.ZswapSecretKeys;
        dustSecretKey: ledger.DustSecretKey;
    }, options: {
        ttl: Date;
        payFees?: boolean;
    }): Promise<UnprovenTransactionRecipe>;
    registerNightUtxosForDustGeneration(nightUtxos: readonly UtxoWithMeta[], nightVerifyingKey: ledger.SignatureVerifyingKey, signDustRegistration: (payload: Uint8Array) => ledger.Signature, dustReceiverAddress?: string): Promise<UnprovenTransactionRecipe>;
    deregisterFromDustGeneration(nightUtxos: UtxoWithMeta[], nightVerifyingKey: ledger.SignatureVerifyingKey, signDustRegistration: (payload: Uint8Array) => ledger.Signature): Promise<UnprovenTransactionRecipe>;
    start(shieldedSecretKeys: ledger.ZswapSecretKeys, dustSecretKey: ledger.DustSecretKey): Promise<void>;
    stop(): Promise<void>;
}
export {};
