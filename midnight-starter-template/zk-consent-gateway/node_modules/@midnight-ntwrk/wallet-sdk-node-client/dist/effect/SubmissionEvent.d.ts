import { Data } from 'effect';
import { SerializedMnTransaction } from './NodeClient.js';
export type HexString = string;
export type SubmissionEvent = Cases.Submitted | Cases.InBlock | Cases.Finalized;
export declare const Submitted: Data.Case.Constructor<Cases.Submitted, "_tag">, InBlock: Data.Case.Constructor<Cases.InBlock, "_tag">, Finalized: Data.Case.Constructor<Cases.Finalized, "_tag">, match: {
    <const Cases extends {
        readonly Submitted: (args: Cases.Submitted) => any;
        readonly InBlock: (args: Cases.InBlock) => any;
        readonly Finalized: (args: Cases.Finalized) => any;
    }>(cases: Cases & { [K in Exclude<keyof Cases, "Submitted" | "InBlock" | "Finalized">]: never; }): (value: SubmissionEvent) => import("effect/Unify").Unify<ReturnType<Cases["Submitted" | "InBlock" | "Finalized"]>>;
    <const Cases extends {
        readonly Submitted: (args: Cases.Submitted) => any;
        readonly InBlock: (args: Cases.InBlock) => any;
        readonly Finalized: (args: Cases.Finalized) => any;
    }>(value: SubmissionEvent, cases: Cases & { [K in Exclude<keyof Cases, "Submitted" | "InBlock" | "Finalized">]: never; }): import("effect/Unify").Unify<ReturnType<Cases["Submitted" | "InBlock" | "Finalized"]>>;
}, is: <Tag extends "Submitted" | "InBlock" | "Finalized">(tag: Tag) => (u: unknown) => u is Extract<Cases.Submitted, {
    readonly _tag: Tag;
}> | Extract<Cases.InBlock, {
    readonly _tag: Tag;
}> | Extract<Cases.Finalized, {
    readonly _tag: Tag;
}>;
export declare namespace Cases {
    type Submitted = {
        _tag: 'Submitted';
        tx: SerializedMnTransaction;
        txHash: HexString;
    };
    type InBlock = {
        _tag: 'InBlock';
        blockHash: HexString;
        blockHeight: bigint;
        tx: SerializedMnTransaction;
        txHash: HexString;
    };
    type Finalized = {
        _tag: 'Finalized';
        blockHash: HexString;
        blockHeight: bigint;
        tx: SerializedMnTransaction;
        txHash: HexString;
    };
}
