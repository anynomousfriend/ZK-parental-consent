// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Deferred, Effect, Encoding, Exit, pipe, Scope } from 'effect';
import { NodeClient, PolkadotNodeClient, SubmissionEvent as SubmissionEventImported, } from '@midnight-ntwrk/wallet-sdk-node-client/effect';
import { WalletError } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
export const SubmissionEvent = SubmissionEventImported;
export const makeDefaultSubmissionService = (config) => {
    const scopeAndClientDeferred = Deferred.make().pipe(Effect.runSync);
    const makeScopeAndClient = Effect.gen(function* () {
        const scope = yield* Scope.make();
        const client = yield* PolkadotNodeClient.make({
            nodeURL: config.relayURL,
        }).pipe(Effect.provideService(Scope.Scope, scope));
        return { scope, client };
    });
    void pipe(scopeAndClientDeferred, Deferred.complete(makeScopeAndClient), Effect.runPromise);
    const submit = (transaction, waitForStatus = 'InBlock') => {
        return pipe(NodeClient.sendMidnightTransactionAndWait(transaction.serialize(), waitForStatus), Effect.provideServiceEffect(NodeClient.NodeClient, pipe(scopeAndClientDeferred, Deferred.await, Effect.map(({ client }) => client))), Effect.mapError((err) => WalletError.WalletError.submission(err)));
    };
    return {
        submitTransaction: submit,
        close() {
            return pipe(scopeAndClientDeferred, Deferred.await, Effect.flatMap(({ scope }) => Scope.close(scope, Exit.void)), Effect.ignoreLogged);
        },
    };
};
export const makeSimulatorSubmissionService = (waitForStatus = 'InBlock') => (config) => {
    const submit = (transaction) => {
        const serializedTx = transaction.serialize();
        return config.simulator.submitRegularTx(transaction).pipe(Effect.map((output) => {
            // Let's mimic node's client behavior here
            switch (waitForStatus) {
                case 'Submitted':
                    return SubmissionEvent.Submitted({
                        tx: serializedTx,
                        txHash: Encoding.encodeHex(serializedTx.subarray(0, 32)),
                    });
                case 'InBlock':
                    return SubmissionEvent.InBlock({
                        tx: serializedTx,
                        blockHash: output.blockHash,
                        blockHeight: output.blockNumber,
                        txHash: Encoding.encodeHex(serializedTx.subarray(0, 32)),
                    });
                case 'Finalized':
                    return SubmissionEvent.Finalized({
                        tx: serializedTx,
                        blockHash: output.blockHash,
                        blockHeight: output.blockNumber,
                        txHash: Encoding.encodeHex(serializedTx.subarray(0, 32)),
                    });
            }
        }));
    };
    return {
        submitTransaction: submit,
        close: () => Effect.void,
    };
};
