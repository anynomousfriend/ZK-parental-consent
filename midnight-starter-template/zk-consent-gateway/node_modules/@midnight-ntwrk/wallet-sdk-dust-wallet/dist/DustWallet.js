// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { DustSecretKey, } from '@midnight-ntwrk/ledger-v7';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { DustAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { WalletBuilder } from '@midnight-ntwrk/wallet-sdk-runtime';
import { Effect, Either } from 'effect';
import * as rx from 'rxjs';
import { DustCoreWallet } from './DustCoreWallet.js';
import { V1Tag } from './RunningV1Variant.js';
import { V1Builder } from './V1Builder.js';
export class DustWalletState {
    static mapState = (capabilities) => (state) => {
        return new DustWalletState(state, capabilities);
    };
    protocolVersion;
    state;
    capabilities;
    get totalCoins() {
        return this.capabilities.coinsAndBalances.getTotalCoins(this.state);
    }
    get availableCoins() {
        return this.capabilities.coinsAndBalances.getAvailableCoins(this.state);
    }
    get pendingCoins() {
        return this.capabilities.coinsAndBalances.getPendingCoins(this.state);
    }
    get dustPublicKey() {
        return this.capabilities.keys.getDustPublicKey(this.state);
    }
    get dustAddress() {
        return DustAddress.encodePublicKey(this.state.networkId, this.dustPublicKey);
    }
    get progress() {
        return {
            appliedIndex: this.state.progress.appliedIndex,
            highestRelevantWalletIndex: this.state.progress.highestRelevantWalletIndex,
            highestIndex: this.state.progress.highestIndex,
            highestRelevantIndex: this.state.progress.highestRelevantIndex,
        };
    }
    constructor(state, capabilities) {
        this.protocolVersion = state.version;
        this.state = state.state;
        this.capabilities = capabilities;
    }
    walletBalance(time) {
        return this.capabilities.coinsAndBalances.getWalletBalance(this.state, time);
    }
    availableCoinsWithFullInfo(time) {
        return this.capabilities.coinsAndBalances.getAvailableCoinsWithFullInfo(this.state, time);
    }
    estimateDustGeneration(nightUtxos, currentTime) {
        return this.capabilities.coinsAndBalances.estimateDustGeneration(this.state, nightUtxos, currentTime);
    }
    serialize() {
        return this.capabilities.serialization.serialize(this.state);
    }
}
export function DustWallet(configuration) {
    const BaseWallet = WalletBuilder.init()
        .withVariant(ProtocolVersion.MinSupportedVersion, new V1Builder().withDefaults())
        .build(configuration);
    return class DustWalletImplementation extends BaseWallet {
        static startWithSeed(seed, dustParameters) {
            const dustSecretKey = DustSecretKey.fromSeed(seed);
            return DustWalletImplementation.startFirst(DustWalletImplementation, DustCoreWallet.initEmpty(dustParameters, dustSecretKey, configuration.networkId));
        }
        static startWithSecretKey(secretKey, dustParameters) {
            return DustWalletImplementation.startFirst(DustWalletImplementation, DustCoreWallet.initEmpty(dustParameters, secretKey, configuration.networkId));
        }
        static restore(serializedState) {
            const deserialized = DustWalletImplementation.allVariantsRecord()[V1Tag].variant.deserializeState(serializedState)
                .pipe(Either.getOrThrow);
            return DustWalletImplementation.startFirst(DustWalletImplementation, deserialized);
        }
        state;
        constructor(runtime, scope) {
            super(runtime, scope);
            this.state = this.rawState.pipe(rx.map(DustWalletState.mapState(DustWalletImplementation.allVariantsRecord()[V1Tag].variant)), rx.shareReplay({ refCount: true, bufferSize: 1 }));
        }
        start(secretKey) {
            return this.runtime.dispatch({ [V1Tag]: (v1) => v1.startSyncInBackground(secretKey) }).pipe(Effect.runPromise);
        }
        createDustGenerationTransaction(currentTime, ttl, nightUtxos, nightVerifyingKey, dustReceiverAddress) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.createDustGenerationTransaction(currentTime, ttl, nightUtxos, nightVerifyingKey, dustReceiverAddress),
            })
                .pipe(Effect.runPromise);
        }
        addDustGenerationSignature(transaction, signature) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.addDustGenerationSignature(transaction, signature),
            })
                .pipe(Effect.runPromise);
        }
        calculateFee(transactions) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.calculateFee(transactions),
            })
                .pipe(Effect.runPromise);
        }
        balanceTransactions(secretKey, transactions, ttl, currentTime) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.balanceTransactions(secretKey, transactions, ttl, currentTime),
            })
                .pipe(Effect.runPromise);
        }
        proveTransaction(transaction) {
            return this.runtime
                .dispatch({
                [V1Tag]: (v1) => v1.proveTransaction(transaction),
            })
                .pipe(Effect.runPromise);
        }
        submitTransaction = ((tx, waitForStatus = 'InBlock') => {
            return this.runtime
                .dispatch({ [V1Tag]: (v1) => v1.submitTransaction(tx, waitForStatus) })
                .pipe(Effect.runPromise);
        });
        waitForSyncedState(allowedGap = 0n) {
            return rx.firstValueFrom(this.state.pipe(rx.filter((state) => state.state.progress.isCompleteWithin(allowedGap))));
        }
        /**
         * Serializes the most recent state
         * It's preferable to use [[DustWalletState.serialize]] instead, to know exactly, which state is serialized
         */
        serializeState() {
            return rx.firstValueFrom(this.state).then((state) => state.serialize());
        }
    };
}
