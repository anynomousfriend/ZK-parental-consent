import { Data } from 'effect';
import { VersionChangeType } from './VersionChangeType.js';
/**
 * A tagged enum data type that represents the state changes across wallet implementation variants.
 *
 * @remarks
 * A variant can report changes in state using the {@link StateChange.State} enum variant. The
 * {@link StateChange.ProgressUpdate} and {@link StateChange.VersionChange} enum variants should be used when a
 * variant needs to report a sync progress update, or a detected change in protocol version respectively.
 */
export type StateChange<TState> = Data.TaggedEnum<{
    /** A change in state. */
    State: {
        readonly state: TState;
    };
    /** A change in reported progress. */
    ProgressUpdate: {
        /**
         * The number of blocks that remain for the underlying datasource to process in order to be fully synchronized.
         */
        readonly sourceGap: bigint;
        /**
         * The number of blocks that remain for the variant to apply in order to be fully synchronized.
         */
        readonly applyGap: bigint;
    };
    /** A change in Midnight protocol version. */
    VersionChange: {
        readonly change: VersionChangeType;
    };
}>;
/**
 * A type predicate that determines if a given value is a {@link StateChange.State} enum variant.
 */
export declare const isState: {
    <T extends {
        readonly _tag: "State";
        readonly state: any;
    } | {
        readonly _tag: "ProgressUpdate";
        readonly sourceGap: bigint;
        readonly applyGap: bigint;
    } | {
        readonly _tag: "VersionChange";
        readonly change: VersionChangeType;
    }>(u: T): u is T & {
        readonly _tag: "State";
    };
    (u: unknown): u is {
        readonly _tag: "State";
        readonly state: unknown;
    };
};
/**
 * A type predicate that determines if a given value is a {@link StateChange.ProgressUpdate} enum variant.
 */
export declare const isProgressUpdate: {
    <T extends {
        readonly _tag: "State";
        readonly state: any;
    } | {
        readonly _tag: "ProgressUpdate";
        readonly sourceGap: bigint;
        readonly applyGap: bigint;
    } | {
        readonly _tag: "VersionChange";
        readonly change: VersionChangeType;
    }>(u: T): u is T & {
        readonly _tag: "ProgressUpdate";
    };
    (u: unknown): u is {
        readonly _tag: "ProgressUpdate";
        readonly sourceGap: bigint;
        readonly applyGap: bigint;
    };
};
/**
 * A type predicate that determines if a given value is a {@link StateChange.VersionChange} enum variant.
 */
export declare const isVersionChange: {
    <T extends {
        readonly _tag: "State";
        readonly state: any;
    } | {
        readonly _tag: "ProgressUpdate";
        readonly sourceGap: bigint;
        readonly applyGap: bigint;
    } | {
        readonly _tag: "VersionChange";
        readonly change: VersionChangeType;
    }>(u: T): u is T & {
        readonly _tag: "VersionChange";
    };
    (u: unknown): u is {
        readonly _tag: "VersionChange";
        readonly change: VersionChangeType;
    };
};
export declare const match: {
    <A, B, C, D, Cases extends {
        readonly State: (args: {
            readonly _tag: "State";
            readonly state: A;
        }) => any;
        readonly ProgressUpdate: (args: {
            readonly _tag: "ProgressUpdate";
            readonly sourceGap: bigint;
            readonly applyGap: bigint;
        }) => any;
        readonly VersionChange: (args: {
            readonly _tag: "VersionChange";
            readonly change: VersionChangeType;
        }) => any;
    }>(cases: Cases & { [K in Exclude<keyof Cases, "State" | "ProgressUpdate" | "VersionChange">]: never; }): (self: {
        readonly _tag: "State";
        readonly state: A;
    } | {
        readonly _tag: "ProgressUpdate";
        readonly sourceGap: bigint;
        readonly applyGap: bigint;
    } | {
        readonly _tag: "VersionChange";
        readonly change: VersionChangeType;
    }) => import("effect/Unify").Unify<ReturnType<Cases["State" | "ProgressUpdate" | "VersionChange"]>>;
    <A, B, C, D, Cases extends {
        readonly State: (args: {
            readonly _tag: "State";
            readonly state: A;
        }) => any;
        readonly ProgressUpdate: (args: {
            readonly _tag: "ProgressUpdate";
            readonly sourceGap: bigint;
            readonly applyGap: bigint;
        }) => any;
        readonly VersionChange: (args: {
            readonly _tag: "VersionChange";
            readonly change: VersionChangeType;
        }) => any;
    }>(self: {
        readonly _tag: "State";
        readonly state: A;
    } | {
        readonly _tag: "ProgressUpdate";
        readonly sourceGap: bigint;
        readonly applyGap: bigint;
    } | {
        readonly _tag: "VersionChange";
        readonly change: VersionChangeType;
    }, cases: Cases & { [K in Exclude<keyof Cases, "State" | "ProgressUpdate" | "VersionChange">]: never; }): import("effect/Unify").Unify<ReturnType<Cases["State" | "ProgressUpdate" | "VersionChange"]>>;
}, State: <A>(args: {
    readonly state: A;
}) => {
    readonly _tag: "State";
    readonly state: A;
}, ProgressUpdate: <A>(args: {
    readonly sourceGap: bigint;
    readonly applyGap: bigint;
}) => {
    readonly _tag: "ProgressUpdate";
    readonly sourceGap: bigint;
    readonly applyGap: bigint;
}, VersionChange: <A>(args: {
    readonly change: VersionChangeType;
}) => {
    readonly _tag: "VersionChange";
    readonly change: VersionChangeType;
};
