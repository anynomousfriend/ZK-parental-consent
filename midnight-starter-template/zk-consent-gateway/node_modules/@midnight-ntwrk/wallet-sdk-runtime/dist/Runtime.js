// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Either, Exit, Option, Scope, Stream, SubscriptionRef, SynchronizedRef } from 'effect';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { StateChange, VersionChangeType, WalletRuntimeError } from './abstractions/index.js';
import { EitherOps, HList, Poly } from '@midnight-ntwrk/wallet-sdk-utilities';
export const initHead = (initArgs) => {
    const headVariant = HList.head(initArgs.variants);
    return init({
        variants: initArgs.variants,
        tag: Poly.getTag(headVariant.variant),
        state: initArgs.state,
    });
};
export const init = (initArgs) => {
    //Rewritten from generators to better track type issues reported
    return Effect.Do.pipe(Effect.bind('initiatedFirstVariant', () => initVariant(initArgs)), Effect.bind('currentStateRef', ({ initiatedFirstVariant }) => initiatedFirstVariant.currentStateRef.get.pipe(Effect.flatMap((state) => SubscriptionRef.make(Either.right({ version: initiatedFirstVariant.initProtocolVersion, state }))))), Effect.bind('progressRef', () => SynchronizedRef.make({ applyGap: 0n, sourceGap: 0n })), Effect.bind('currentVariantRef', ({ initiatedFirstVariant }) => Effect.acquireRelease(SynchronizedRef.make(initiatedFirstVariant), (ref, exit) => Effect.gen(function* () {
        // This is needed to properly close variant scope when whole runtime closes
        // Otherwise variant would be running in the background
        const runningVariant = yield* SynchronizedRef.get(ref);
        yield* Scope.close(runningVariant.variantScope, exit);
    }))), Effect.bind('runningStream', ({ initiatedFirstVariant, currentStateRef, progressRef, currentVariantRef }) => {
        return runVariantStream(initiatedFirstVariant, currentStateRef, progressRef, currentVariantRef).pipe(Effect.catchAll((error) => {
            return SubscriptionRef.set(currentStateRef, Either.left(error));
        }), Effect.forkScoped);
    }), Effect.flatMap(({ currentStateRef, progressRef, currentVariantRef }) => {
        return Effect.gen(function* () {
            const changesStream = yield* currentStateRef.changes.pipe(Stream.mapEffect((value) => EitherOps.toEffect(value)), Stream.share({ capacity: 'unbounded', replay: 1 }));
            const runtime = {
                stateChanges: changesStream,
                progress: progressRef.get,
                currentVariant: currentVariantRef.get,
                dispatch: (impl) => dispatch(runtime, impl),
            };
            return runtime;
        });
    }));
};
export const dispatch = (runtime, impl) => {
    return runtime.currentVariant.pipe(Effect.flatMap((current) => Poly.dispatch(current.runningVariant, impl)));
};
const migrateToNextVariant = (migrateArgs) => {
    return Effect.gen(function* () {
        const [headVersionedVariant] = migrateArgs.variants;
        if (!headVersionedVariant) {
            yield* Effect.fail(new WalletRuntimeError({ message: 'No variant to init' }));
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- It seems that TS is defaulting to the constraint provided for a generic type with its inference, which includes any
        const newState = yield* headVersionedVariant.variant.migrateState(migrateArgs.state);
        return yield* initHeadVariant({
            variants: migrateArgs.variants,
            state: newState,
            initProtocolVersion: migrateArgs.initProtocolVersion,
        });
    });
};
// Arguments are gathered to a separate type because presence of HList.Find is crashing TS compiler ¯\_(ツ)_/¯
const initVariant = (init) => {
    return Effect.gen(function* () {
        const index = init.variants.findIndex((variant) => Poly.getTag(variant.variant) === init.tag);
        const theRest = init.variants.toSpliced(0, index);
        //These casts are terrible, but they allow to call the initHeadVariant
        return yield* initHeadVariant({
            variants: theRest,
            state: init.state,
            initProtocolVersion: undefined,
        });
    });
};
// Following pattern from `initVariant` for consistency
const initHeadVariant = (init) => {
    return Effect.gen(function* () {
        const [anyHeadVersionedVariant, maybeNextVersionedVariant] = init.variants;
        if (!anyHeadVersionedVariant) {
            yield* Effect.fail(new WalletRuntimeError({ message: 'No variant to init' }));
        }
        const headVersionedVariant = anyHeadVersionedVariant;
        const actualInitProtocolVersion = init.initProtocolVersion ?? headVersionedVariant.sinceVersion;
        const nextActivationVersion = maybeNextVersionedVariant
            ? maybeNextVersionedVariant.sinceVersion
            : ProtocolVersion.MaxSupportedVersion;
        const validVersionRange = ProtocolVersion.makeRange(headVersionedVariant.sinceVersion, nextActivationVersion);
        const stateRef = yield* SubscriptionRef.make(init.state);
        const variantScope = yield* Scope.make();
        const runningVariant = yield* headVersionedVariant.variant
            .start({ stateRef })
            .pipe(Effect.provideService(Scope.Scope, variantScope));
        //This type declaration helps with setting right properties...
        const out = {
            __polyTag__: headVersionedVariant.variant.__polyTag__,
            variant: headVersionedVariant,
            initialState: init.state,
            runningVariant: runningVariant,
            currentStateRef: stateRef,
            restVariants: HList.tail(init.variants),
            initProtocolVersion: actualInitProtocolVersion,
            validVersionRange,
            nextProtocolVersion: maybeNextVersionedVariant ? maybeNextVersionedVariant.sinceVersion : null,
            variantScope,
        };
        // ...while this type casting makes things bearable in the rest of the code (TS's type inference is great, but still limited)
        return out;
    });
};
const runVariantStream = (initiatedVariant, stateRef, progressRef, currentVariantRef) => {
    const initialAcc = {
        protocolVersion: initiatedVariant.initProtocolVersion,
        shouldInitChange: false,
        followEffect: Effect.void,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        lastState: initiatedVariant.initialState,
    };
    return initiatedVariant.runningVariant.state.pipe(Stream.scanEffect(initialAcc, (accumulator, change) => {
        return StateChange.match(change, {
            State: ({ state }) => {
                return SubscriptionRef.set(stateRef, Either.right({ version: accumulator.protocolVersion, state })).pipe(Effect.as({ ...accumulator, lastState: state }));
            },
            ProgressUpdate: (progress) => {
                return SynchronizedRef.set(progressRef, progress).pipe(Effect.as(accumulator));
            },
            VersionChange: ({ change }) => {
                const newProtocolVersion = VersionChangeType.match(change, {
                    Version: ({ version }) => version,
                    Next: () => initiatedVariant.nextProtocolVersion,
                });
                if (newProtocolVersion != null &&
                    !ProtocolVersion.withinRange(newProtocolVersion, initiatedVariant.validVersionRange)) {
                    return Effect.succeed({
                        ...accumulator,
                        protocolVersion: newProtocolVersion,
                        shouldInitChange: true,
                        followEffect: Effect.gen(function* () {
                            yield* Scope.close(initiatedVariant.variantScope, Exit.void);
                            const newInitiatedVariant = yield* migrateToNextVariant({
                                variants: initiatedVariant.restVariants,
                                state: accumulator.lastState,
                                initProtocolVersion: newProtocolVersion,
                            });
                            yield* SynchronizedRef.set(currentVariantRef, newInitiatedVariant);
                            return yield* runVariantStream(newInitiatedVariant, stateRef, progressRef, currentVariantRef);
                        }),
                    });
                }
                else {
                    return Effect.succeed({
                        ...accumulator,
                        protocolVersion: newProtocolVersion ?? accumulator.protocolVersion,
                    });
                }
            },
        });
    }), Stream.filter((streamAcc) => streamAcc.shouldInitChange), Stream.runHead, Effect.flatMap((streamAccOption) => {
        return Option.match(streamAccOption, {
            onSome: (value) => {
                return value.followEffect;
            },
            onNone: () => {
                return Effect.void;
            },
        });
    }));
};
