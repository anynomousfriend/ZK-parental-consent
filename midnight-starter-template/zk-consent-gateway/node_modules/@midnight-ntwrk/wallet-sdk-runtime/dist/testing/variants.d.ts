import { Variant, VariantBuilder, VersionChangeType, WalletRuntimeError } from '../abstractions/index.js';
import { Effect, Scope } from 'effect';
export type RangeConfig = {
    min: number;
    max: number;
};
export declare const Numeric: "NumericRange";
export declare class NumericRange implements Variant.Variant<typeof Numeric, number, null, Variant.RunningVariant<typeof Numeric, number>> {
    #private;
    __polyTag__: typeof Numeric;
    protected configuration: RangeConfig;
    protected yieldCount: number;
    protected throwError: boolean;
    constructor(configuration: RangeConfig, yieldCount: number, throwError: boolean);
    get currentState(): number;
    start(context: Variant.VariantContext<number>): Effect.Effect<Variant.RunningVariant<typeof Numeric, number>>;
    migrateState(): Effect.Effect<number>;
}
export declare class NumericRangeBuilder implements VariantBuilder.VariantBuilder<NumericRange, RangeConfig> {
    private readonly yieldCount;
    private readonly throwError;
    constructor(yieldCount?: number, throwError?: boolean);
    build(configuration: RangeConfig): NumericRange;
}
export type RangeMultiplierConfig = RangeConfig & {
    multiplier: number;
};
export declare const NumericMultiplier = "NumericMultiplier";
export declare class NumericRangeMultiplier implements Variant.Variant<typeof NumericMultiplier, number, number, Variant.RunningVariant<typeof NumericMultiplier, number>> {
    #private;
    __polyTag__: typeof NumericMultiplier;
    protected configuration: RangeMultiplierConfig;
    constructor(configuration: RangeMultiplierConfig);
    get currentState(): number;
    start(context: Variant.VariantContext<number>): Effect.Effect<Variant.RunningVariant<typeof NumericMultiplier, number>>;
    migrateState(state: number): Effect.Effect<number>;
}
export declare class NumericRangeMultiplierBuilder implements VariantBuilder.VariantBuilder<NumericRangeMultiplier, RangeMultiplierConfig> {
    build(configuration: RangeMultiplierConfig): NumericRangeMultiplier;
}
export type InterceptingRunningVariant<TTag extends string | symbol, TState> = Variant.RunningVariant<TTag, TState> & {
    emitProtocolVersionChange: (change: VersionChangeType.VersionChangeType) => Effect.Effect<void>;
};
export declare class InterceptingVariant<TTag extends string | symbol, TState> implements Variant.Variant<TTag, TState, TState, InterceptingRunningVariant<TTag, TState>> {
    __polyTag__: TTag;
    constructor(tag: TTag);
    migrateState(previousState: TState): Effect.Effect<TState>;
    start(context: Variant.VariantContext<TState>): Effect.Effect<InterceptingRunningVariant<TTag, TState>, WalletRuntimeError, Scope.Scope>;
}
/**
 * Builder of an intercepting variant
 * It allows removing the possibility of race conditions by requiring an explicit gesture to migrate to a next/specific protocol version
 */
export declare class InterceptingVariantBuilder<TTag extends string | symbol, TState> implements VariantBuilder.VariantBuilder<InterceptingVariant<TTag, TState>, object> {
    tag: TTag;
    constructor(tag: TTag);
    build(): InterceptingVariant<TTag, TState>;
}
