import { createProvingPayload, createCheckPayload, parseCheckResult, CostModel } from '@midnight-ntwrk/ledger-v7';
import { InvalidProtocolSchemeError, zkConfigToProvingKeyMaterial } from '@midnight-ntwrk/midnight-js-types';
import fetch from 'cross-fetch';
import fetchBuilder from 'fetch-retry';

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const retryOptions = {
    retries: 3,
    retryDelay: (attempt) => 2 ** attempt * 1_000,
    retryOn: [500, 503]
};
const fetchRetry = fetchBuilder(fetch, retryOptions);
const CHECK_PATH = '/check';
const PROVE_PATH = '/prove';
const DEFAULT_TIMEOUT = 300000;
const getKeyMaterial = async (zkConfigProvider, keyLocation) => {
    try {
        const zkConfig = await zkConfigProvider.get(keyLocation);
        return zkConfigToProvingKeyMaterial(zkConfig);
    }
    catch {
        return undefined;
    }
};
const makeHttpRequest = async (url, payload, timeout) => {
    const response = await fetchRetry(url, {
        method: 'POST',
        body: payload.buffer,
        signal: AbortSignal.timeout(timeout)
    });
    if (!response.ok) {
        throw new Error(`Failed Proof Server response: url="${response.url}", code="${response.status}", status="${response.statusText}"`);
    }
    return new Uint8Array(await response.arrayBuffer());
};
const httpClientProvingProvider = (url, zkConfigProvider, config) => {
    const checkUrl = new URL(CHECK_PATH, url);
    const proveUrl = new URL(PROVE_PATH, url);
    if (checkUrl.protocol !== 'http:' && checkUrl.protocol !== 'https:') {
        throw new InvalidProtocolSchemeError(checkUrl.protocol, ['http:', 'https:']);
    }
    if (proveUrl.protocol !== 'http:' && proveUrl.protocol !== 'https:') {
        throw new InvalidProtocolSchemeError(proveUrl.protocol, ['http:', 'https:']);
    }
    const timeout = config?.timeout ?? DEFAULT_TIMEOUT;
    return {
        async check(serializedPreimage, keyLocation) {
            const keyMaterial = await getKeyMaterial(zkConfigProvider, keyLocation);
            const payload = createCheckPayload(serializedPreimage, keyMaterial?.ir);
            const result = await makeHttpRequest(checkUrl, payload, timeout);
            return parseCheckResult(result);
        },
        async prove(serializedPreimage, keyLocation, overwriteBindingInput) {
            const keyMaterial = await getKeyMaterial(zkConfigProvider, keyLocation);
            const payload = createProvingPayload(serializedPreimage, overwriteBindingInput, keyMaterial);
            return makeHttpRequest(proveUrl, payload, timeout);
        }
    };
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_CONFIG = {
    timeout: 300000,
    zkConfig: undefined
};
/**
 * Creates a high-level {@link ProofProvider} that implements transaction-level proving
 * using the low-level circuit-by-circuit {@link ProvingProvider} as its foundation.
 *
 * This adapter bridges the gap between:
 * - High-level ProofProvider interface (works with complete transactions)
 * - Low-level ProvingProvider interface (works with individual circuits)
 *
 * @param url The URL of the proof server
 * @param zkConfigProvider Provider for zero-knowledge configuration artifacts
 * @param config Optional configuration for the underlying ProvingProvider
 * @returns A ProofProvider instance that uses ProvingProvider internally
 *
 * @remarks
 * **Architecture:**
 * ```
 * ProofProvider (Transaction-level)
 *     ↓ (adapter)
 * ProvingProvider (Circuit-level)
 *     ↓ (HTTP client)
 * Proof Server (/check, /prove endpoints)
 * ```
 *
 * **Note:** The /prove-tx endpoint is NOT used. All proving is done through
 * individual circuit operations using /check and /prove endpoints.
 */
const httpClientProofProvider = (url, zkConfigProvider, config) => {
    const baseProvingProvider = httpClientProvingProvider(url, zkConfigProvider, config);
    return {
        async proveTx(unprovenTx, _partialProveTxConfig) {
            const costModel = CostModel.initialCostModel();
            return unprovenTx.prove(baseProvingProvider, costModel);
        }
    };
};

export { DEFAULT_CONFIG, DEFAULT_TIMEOUT, httpClientProofProvider, httpClientProvingProvider };
//# sourceMappingURL=index.mjs.map
