pragma language_version >= 0.20;

import CompactStandardLibrary;

// Store mapping of child hash to a boolean (consent granted or not)
// In Compact, we cannot access transaction sender in circuits
// So we simplify to just track if consent exists
export ledger consent_registry: Map<Field, Boolean>;

/**
 * PARENT ACTION: Grant Consent
 * This is called by the parent to add a child's hashed ID to the ledger.
 * Note: Compact circuits cannot access transaction sender directly.
 * Authentication is handled at the wallet/transaction level.
 */
export circuit grant_consent(child_id_hash: Field): [] {
    // Disclose the child ID hash
    const disclosed_hash = disclose(child_id_hash);
    
    // Store the consent in the registry
    consent_registry.insert(disclosed_hash, true);
}

/**
 * PARENT ACTION: Revoke Consent
 * This allows removal of consent for a child.
 * Note: In production, you'd want to track who granted consent
 * using off-chain authentication or a different mechanism.
 */
export circuit revoke_consent(child_id_hash: Field): [] {
    const disclosed_hash = disclose(child_id_hash);
    
    // Remove the consent from the registry
    consent_registry.remove(disclosed_hash);
}

/**
 * CHILD ACTION: Prove Consent
 * This is a 'witness' circuit. It doesn't change the ledger.
 * It proves the child belongs to an authorized hash without revealing which one.
 */
export circuit verify_minor_access(
    // Public Input: What the platform sees (nothing in this case, just the proof)
    // Private Witness: The secret data only the child knows
    child_id_hash: Field 
): Boolean {
    // 1. Disclose the hash to check it against the registry
    const disclosed_hash = disclose(child_id_hash);
    
    // 2. Check if the provided hash exists in our public registry
    const is_authorized = consent_registry.lookup(disclosed_hash);
    
    // 3. The circuit will only 'pass' and generate a valid ZK Proof 
    // if the minor actually knows an ID that is in the registry.
    return is_authorized;
}