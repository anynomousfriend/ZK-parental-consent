import { Effect, Either, Scope, Stream, SubscriptionRef } from 'effect';
import { LedgerState, BlockContext, UserAddress, SignatureVerifyingKey, WellFormedStrictness, TransactionResult, ProofErasedTransaction, SyntheticCost } from '@midnight-ntwrk/ledger-v7';
import { LedgerOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { NetworkId } from './types/ledger.js';
export type SimulatorState = Readonly<{
    networkId: NetworkId;
    ledger: LedgerState;
    lastTx: ProofErasedTransaction | undefined;
    lastTxResult: TransactionResult | undefined;
    lastTxNumber: bigint;
}>;
export declare class Simulator {
    #private;
    static blockHash: (blockTime: Date) => Effect.Effect<string>;
    static nextBlockContext: (blockTime: Date) => Effect.Effect<BlockContext>;
    static init(networkId: NetworkId): Effect.Effect<Simulator, never, Scope.Scope>;
    static apply(simulatorState: SimulatorState, tx: ProofErasedTransaction, strictness: WellFormedStrictness, blockContext: BlockContext, blockFullness?: SyntheticCost): Either.Either<[{
        blockNumber: bigint;
        blockHash: string;
    }, SimulatorState], LedgerOps.LedgerError>;
    readonly state$: Stream.Stream<SimulatorState>;
    constructor(stateRef: SubscriptionRef.SubscriptionRef<SimulatorState>, state$: Stream.Stream<SimulatorState>);
    getLatestState(): Effect.Effect<SimulatorState>;
    rewardNight(recipient: UserAddress, amount: bigint, verifyingKey: SignatureVerifyingKey): Effect.Effect<{
        blockNumber: bigint;
        blockHash: string;
    }, LedgerOps.LedgerError>;
    submitRegularTx(tx: ProofErasedTransaction, blockFullness?: SyntheticCost): Effect.Effect<{
        blockNumber: bigint;
        blockHash: string;
    }, LedgerOps.LedgerError>;
    fastForward(lastTxNumber: bigint): Effect.Effect<undefined, LedgerOps.LedgerError>;
}
