import { Either } from 'effect';
import { DustSecretKey, Signature, SignatureVerifyingKey, FinalizedTransaction, ProofErasedTransaction, UnprovenTransaction, LedgerParameters } from '@midnight-ntwrk/ledger-v7';
import { WalletError } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { DustCoreWallet } from './DustCoreWallet.js';
import { AnyTransaction, DustToken, NetworkId, TotalCostParameters } from './types/index.js';
import { CoinsAndBalancesCapability, CoinSelection, UtxoWithFullDustDetails } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';
export interface TransactingCapability<TSecrets, TState, TTransaction> {
    readonly networkId: NetworkId;
    readonly costParams: TotalCostParameters;
    createDustGenerationTransaction(currentTime: Date, ttl: Date, nightUtxos: ReadonlyArray<UtxoWithFullDustDetails>, nightVerifyingKey: SignatureVerifyingKey, dustReceiverAddress: string | undefined): Either.Either<UnprovenTransaction, WalletError.WalletError>;
    addDustGenerationSignature(transaction: UnprovenTransaction, signature: Signature): Either.Either<UnprovenTransaction, WalletError.WalletError>;
    calculateFee(transaction: AnyTransaction, ledgerParams: LedgerParameters): bigint;
    balanceTransactions(secretKey: TSecrets, state: TState, transactions: ReadonlyArray<AnyTransaction>, ttl: Date, currentTime: Date, ledgerParams: LedgerParameters): Either.Either<[UnprovenTransaction, TState], WalletError.WalletError>;
    revertTransaction(state: TState, transaction: UnprovenTransaction | TTransaction): Either.Either<TState, WalletError.WalletError>;
}
export type DefaultTransactingConfiguration = {
    networkId: NetworkId;
    costParameters: TotalCostParameters;
};
export type DefaultTransactingContext = {
    coinSelection: CoinSelection<DustToken>;
    coinsAndBalancesCapability: CoinsAndBalancesCapability<DustCoreWallet>;
    keysCapability: KeysCapability<DustCoreWallet>;
};
export declare const makeDefaultTransactingCapability: (config: DefaultTransactingConfiguration, getContext: () => DefaultTransactingContext) => TransactingCapability<DustSecretKey, DustCoreWallet, FinalizedTransaction>;
export declare const makeSimulatorTransactingCapability: (config: DefaultTransactingConfiguration, getContext: () => DefaultTransactingContext) => TransactingCapability<DustSecretKey, DustCoreWallet, ProofErasedTransaction>;
export declare class TransactingCapabilityImplementation<TTransaction extends AnyTransaction> implements TransactingCapability<DustSecretKey, DustCoreWallet, TTransaction> {
    #private;
    readonly networkId: string;
    readonly costParams: TotalCostParameters;
    readonly getCoinSelection: () => CoinSelection<DustToken>;
    readonly getCoins: () => CoinsAndBalancesCapability<DustCoreWallet>;
    readonly getKeys: () => KeysCapability<DustCoreWallet>;
    constructor(networkId: NetworkId, costParams: TotalCostParameters, getCoinSelection: () => CoinSelection<DustToken>, getCoins: () => CoinsAndBalancesCapability<DustCoreWallet>, getKeys: () => KeysCapability<DustCoreWallet>);
    createDustGenerationTransaction(currentTime: Date, ttl: Date, nightUtxos: ReadonlyArray<UtxoWithFullDustDetails>, nightVerifyingKey: SignatureVerifyingKey, dustReceiverAddress: string | undefined): Either.Either<UnprovenTransaction, WalletError.WalletError>;
    addDustGenerationSignature(transaction: UnprovenTransaction, signatureData: Signature): Either.Either<UnprovenTransaction, WalletError.WalletError>;
    calculateFee(transaction: AnyTransaction, ledgerParams: LedgerParameters): bigint;
    static feeImbalance(transaction: AnyTransaction, totalFee: bigint): bigint;
    balanceTransactions(secretKey: DustSecretKey, state: DustCoreWallet, transactions: ReadonlyArray<FinalizedTransaction | UnprovenTransaction>, ttl: Date, currentTime: Date, ledgerParams: LedgerParameters): Either.Either<[UnprovenTransaction, DustCoreWallet], WalletError.WalletError>;
    revertTransaction(state: DustCoreWallet, transaction: UnprovenTransaction | TTransaction): Either.Either<DustCoreWallet, WalletError.WalletError>;
}
