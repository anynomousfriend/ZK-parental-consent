// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Encoding, pipe, Stream, SubscriptionRef } from 'effect';
import { LedgerState, ClaimRewardsTransaction, SignatureErased, Transaction, WellFormedStrictness, TransactionContext, } from '@midnight-ntwrk/ledger-v7';
import { DateOps, EitherOps, LedgerOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import * as crypto from 'crypto';
const simpleHash = (input) => {
    return Encoding.decodeHex(input).pipe(EitherOps.toEffect, Effect.andThen((parsed) => Effect.promise(() => crypto.subtle.digest('SHA-256', parsed))), Effect.andThen((out) => Encoding.encodeHex(new Uint8Array(out))), Effect.orDie);
};
export class Simulator {
    static blockHash = (blockTime) => pipe(DateOps.dateToSeconds(blockTime).toString(16), (str) => (str.length % 2 == 0 ? str : str.padStart(str.length + 1, '0')), simpleHash);
    static nextBlockContext = (blockTime) => pipe(Simulator.blockHash(blockTime), Effect.map((hash) => ({
        parentBlockHash: hash,
        secondsSinceEpoch: DateOps.dateToSeconds(blockTime),
        secondsSinceEpochErr: 1,
    })));
    static init(networkId) {
        return Effect.gen(function* () {
            const initialState = {
                networkId,
                ledger: LedgerState.blank(networkId),
                lastTx: undefined,
                lastTxResult: undefined,
                lastTxNumber: 0n,
            };
            const ref = yield* SubscriptionRef.make(initialState);
            const changesStream = yield* Stream.share(ref.changes, {
                capacity: 'unbounded',
                replay: Number.MAX_SAFE_INTEGER,
            });
            yield* pipe(changesStream, Stream.runDrain, Effect.forkScoped);
            return new Simulator(ref, changesStream);
        });
    }
    static apply(simulatorState, tx, strictness, blockContext, blockFullness) {
        return LedgerOps.ledgerTry(() => {
            blockFullness = blockFullness ?? tx.cost(simulatorState.ledger.parameters);
            const detailedBlockFullness = simulatorState.ledger.parameters.normalizeFullness(blockFullness);
            const computedBlockFullness = Math.max(detailedBlockFullness.readTime, detailedBlockFullness.computeTime, detailedBlockFullness.blockUsage, detailedBlockFullness.bytesWritten, detailedBlockFullness.bytesChurned);
            const blockNumber = blockContext.secondsSinceEpoch;
            const blockTime = DateOps.secondsToDate(blockNumber);
            const verifiedTransaction = tx.wellFormed(simulatorState.ledger, strictness, blockTime);
            const transactionContext = new TransactionContext(simulatorState.ledger, blockContext);
            const [newLedgerState, txResult] = simulatorState.ledger.apply(verifiedTransaction, transactionContext);
            const newSimulatorState = {
                ...simulatorState,
                ledger: newLedgerState.postBlockUpdate(blockTime, detailedBlockFullness, computedBlockFullness),
                lastTx: tx,
                lastTxResult: txResult,
                lastTxNumber: blockNumber,
            };
            const output = {
                blockNumber,
                blockHash: blockContext.parentBlockHash,
            };
            return [output, newSimulatorState];
        });
    }
    #stateRef;
    state$;
    constructor(stateRef, state$) {
        this.#stateRef = stateRef;
        this.state$ = state$;
    }
    getLatestState() {
        return SubscriptionRef.get(this.#stateRef);
    }
    rewardNight(recipient, amount, verifyingKey) {
        return SubscriptionRef.modifyEffect(this.#stateRef, (simulatorState) => Effect.gen(function* () {
            const nextNumber = DateOps.secondsToDate(simulatorState.lastTxNumber + 1n);
            const newLedgerState = yield* LedgerOps.ledgerTry(() => simulatorState.ledger.testingDistributeNight(recipient, amount, nextNumber));
            const newSimulatorState = {
                ...simulatorState,
                ledger: newLedgerState,
            };
            const signature = new SignatureErased();
            const claimRewardsTransaction = new ClaimRewardsTransaction(signature.instance, newSimulatorState.networkId, amount, verifyingKey, LedgerOps.randomNonce(), signature);
            const tx = Transaction.fromRewards(claimRewardsTransaction).eraseProofs();
            const blockContext = yield* Simulator.nextBlockContext(nextNumber);
            return yield* Simulator.apply(newSimulatorState, tx, new WellFormedStrictness(), blockContext);
        }));
    }
    submitRegularTx(tx, blockFullness) {
        return SubscriptionRef.modifyEffect(this.#stateRef, (simulatorState) => Effect.gen(function* () {
            const nextNumber = DateOps.secondsToDate(simulatorState.lastTxNumber + 1n);
            const context = yield* Simulator.nextBlockContext(nextNumber);
            return yield* Simulator.apply(simulatorState, tx, new WellFormedStrictness(), context, blockFullness);
        }));
    }
    fastForward(lastTxNumber) {
        return SubscriptionRef.modify(this.#stateRef, (simulatorState) => {
            return [
                undefined,
                {
                    ...simulatorState,
                    lastTxNumber,
                    lastTx: undefined,
                    lastTxResult: undefined,
                },
            ];
        });
    }
}
