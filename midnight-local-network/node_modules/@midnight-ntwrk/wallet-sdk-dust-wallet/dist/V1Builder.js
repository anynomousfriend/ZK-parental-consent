// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Scope } from 'effect';
import { Proving } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { makeDefaultSyncCapability, makeDefaultSyncService, } from './Sync.js';
import { RunningV1Variant, V1Tag } from './RunningV1Variant.js';
import { makeDefaultKeysCapability } from './Keys.js';
import { chooseCoin, makeDefaultCoinsAndBalancesCapability, } from './CoinsAndBalances.js';
import { makeDefaultTransactingCapability, } from './Transacting.js';
import { makeDefaultSubmissionService } from './Submission.js';
import { makeDefaultV1SerializationCapability } from './Serialization.js';
const V1BuilderSymbol = {
    typeId: Symbol('@midnight-ntwrk/dustWallet#V1Builder'),
};
export class V1Builder {
    #buildState;
    constructor(buildState = {}) {
        this.#buildState = buildState;
    }
    withDefaults() {
        return this.withDefaultTransactionType()
            .withSyncDefaults()
            .withSerializationDefaults()
            .withTransactingDefaults()
            .withCoinsAndBalancesDefaults()
            .withKeysDefaults()
            .withSubmissionDefaults()
            .withProvingDefaults()
            .withCoinSelectionDefaults();
    }
    withTransactionType() {
        return new V1Builder({
            ...this.#buildState,
            provingService: undefined,
            transactingCapability: undefined,
            submissionService: undefined,
        });
    }
    withDefaultTransactionType() {
        return this.withTransactionType();
    }
    withSyncDefaults() {
        return this.withSync(makeDefaultSyncService, makeDefaultSyncCapability);
    }
    withSync(syncService, syncCapability) {
        return new V1Builder({
            ...this.#buildState,
            syncService,
            syncCapability,
        });
    }
    withSerializationDefaults() {
        return this.withSerialization(makeDefaultV1SerializationCapability);
    }
    withSerialization(serializationCapability) {
        return new V1Builder({
            ...this.#buildState,
            serializationCapability,
        });
    }
    withTransactingDefaults() {
        return this.withTransacting(makeDefaultTransactingCapability);
    }
    withTransacting(transactingCapability) {
        return new V1Builder({
            ...this.#buildState,
            transactingCapability,
        });
    }
    withCoinSelection(coinSelection) {
        return new V1Builder({
            ...this.#buildState,
            coinSelection,
        });
    }
    withCoinSelectionDefaults() {
        return this.withCoinSelection(() => chooseCoin);
    }
    withProving(provingService) {
        return new V1Builder({
            ...this.#buildState,
            provingService,
        });
    }
    withProvingDefaults() {
        return this.withProving(Proving.makeDefaultProvingService);
    }
    withCoinsAndBalancesDefaults() {
        return this.withCoinsAndBalances(makeDefaultCoinsAndBalancesCapability);
    }
    withCoinsAndBalances(coinsAndBalancesCapability) {
        return new V1Builder({
            ...this.#buildState,
            coinsAndBalancesCapability,
        });
    }
    withKeysDefaults() {
        return this.withKeys(makeDefaultKeysCapability);
    }
    withKeys(keysCapability) {
        return new V1Builder({
            ...this.#buildState,
            keysCapability,
        });
    }
    withSubmission(submissionService) {
        return new V1Builder({
            ...this.#buildState,
            submissionService,
        });
    }
    withSubmissionDefaults() {
        return this.withSubmission(makeDefaultSubmissionService);
    }
    build(configuration) {
        const v1Context = this.#buildContextFromBuildState(configuration);
        return {
            __polyTag__: V1Tag,
            coinsAndBalances: v1Context.coinsAndBalancesCapability,
            keys: v1Context.keysCapability,
            serialization: v1Context.serializationCapability,
            start(context) {
                return Effect.gen(function* () {
                    yield* Effect.addFinalizer(() => v1Context.submissionService.close());
                    const scope = yield* Scope.Scope;
                    return new RunningV1Variant(scope, context, v1Context);
                });
            },
            migrateState(prevState) {
                // TODO: re-implement
                return Effect.succeed(prevState);
            },
            deserializeState: (serialized) => {
                return v1Context.serializationCapability.deserialize(null, serialized);
            },
        };
    }
    #buildContextFromBuildState(configuration) {
        if (!isBuildStateFull(this.#buildState)) {
            throw new Error('Not all components are configured in V1 Builder');
        }
        const { syncCapability, syncService, transactingCapability, serializationCapability, provingService, coinSelection, coinsAndBalancesCapability, keysCapability, submissionService, } = this.#buildState;
        const getContext = () => context;
        const context = {
            serializationCapability: serializationCapability(configuration, getContext),
            syncCapability: syncCapability(configuration, getContext),
            syncService: syncService(configuration, getContext),
            transactingCapability: transactingCapability(configuration, getContext),
            coinsAndBalancesCapability: coinsAndBalancesCapability(configuration, getContext),
            keysCapability: keysCapability(configuration, getContext),
            provingService: provingService(configuration, getContext),
            coinSelection: coinSelection(configuration, getContext),
            submissionService: submissionService(configuration, getContext),
        };
        return context;
    }
}
const isBuildStateFull = (buildState) => {
    const allBuildStateKeys = [
        'syncService',
        'syncCapability',
        'transactingCapability',
        'coinSelection',
        'serializationCapability',
        'provingService',
        'coinsAndBalancesCapability',
        'keysCapability',
        'submissionService',
    ];
    return allBuildStateKeys.every((key) => typeof buildState[key] == 'function');
};
