// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Either, Layer, ParseResult, pipe, Schema, Stream, Duration, Chunk, Schedule } from 'effect';
import { Event as LedgerEvent, LedgerParameters } from '@midnight-ntwrk/ledger-v7';
import { BlockHash, DustLedgerEvents } from '@midnight-ntwrk/wallet-sdk-indexer-client';
import { WsSubscriptionClient, HttpQueryClient, ConnectionHelper, } from '@midnight-ntwrk/wallet-sdk-indexer-client/effect';
import { DateOps, EitherOps, LedgerOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { WsURL } from '@midnight-ntwrk/wallet-sdk-utilities/networking';
import { WalletError } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { Simulator } from './Simulator.js';
import { Uint8ArraySchema } from './Serialization.js';
export const SecretKeysResource = {
    create: (secretKey) => {
        let sk = secretKey;
        return (cb) => {
            if (sk === null || sk === undefined) {
                throw new Error('Secret key has been consumed');
            }
            const result = cb(sk);
            sk = null;
            return result;
        };
    },
};
const LedgerEventSchema = Schema.declare((input) => input instanceof LedgerEvent).annotations({
    identifier: 'ledger.Event',
});
const LedgerEventFromUInt8Array = Schema.asSchema(Schema.transformOrFail(Uint8ArraySchema, LedgerEventSchema, {
    encode: (e) => {
        return Effect.try({
            try: () => e.serialize(),
            catch: (err) => {
                return new ParseResult.Unexpected(err, 'Could not serialize Ledger Event');
            },
        });
    },
    decode: (bytes) => Effect.try({
        try: () => LedgerEvent.deserialize(bytes),
        catch: (err) => {
            return new ParseResult.Unexpected(err, 'Could not deserialize Ledger Event');
        },
    }),
}));
const HexedEvent = pipe(Schema.Uint8ArrayFromHex, Schema.compose(LedgerEventFromUInt8Array));
export const SyncEventsUpdateSchema = Schema.Struct({
    id: Schema.Number,
    raw: HexedEvent,
    maxId: Schema.Number,
});
export const WalletSyncUpdate = {
    create: (updates, secretKey, timestamp) => {
        return {
            updates,
            secretKeys: SecretKeysResource.create(secretKey),
            timestamp,
        };
    },
};
export const makeDefaultSyncService = (config) => {
    const indexerSyncService = makeIndexerSyncService(config);
    return {
        updates: (state, secretKey) => {
            const batchSize = 10;
            const batchTimeout = Duration.millis(1);
            return pipe(indexerSyncService.subscribeWallet(state), Stream.groupedWithin(batchSize, batchTimeout), Stream.map(Chunk.toArray), Stream.map((data) => WalletSyncUpdate.create(data, secretKey, new Date())), Stream.schedule(Schedule.spaced(Duration.millis(4))), Stream.provideSomeLayer(indexerSyncService.connectionLayer()));
        },
        blockData: () => {
            return Effect.gen(function* () {
                const query = yield* BlockHash;
                const result = yield* query({ offset: null });
                return result.block;
            }).pipe(Effect.provide(indexerSyncService.queryClient()), Effect.scoped, Effect.catchAll((err) => Effect.fail(WalletError.WalletError.other(`Encountered unexpected error: ${err.message}`))), Effect.flatMap((blockData) => {
                if (!blockData) {
                    return Effect.fail(WalletError.WalletError.other('Unable to fetch block data'));
                }
                // TODO: convert to schema
                return LedgerOps.ledgerTry(() => ({
                    hash: blockData.hash,
                    height: blockData.height,
                    ledgerParameters: LedgerParameters.deserialize(Buffer.from(blockData.ledgerParameters, 'hex')),
                    timestamp: new Date(blockData.timestamp),
                }));
            }));
        },
    };
};
export const makeIndexerSyncService = (config) => {
    return {
        queryClient() {
            return pipe(HttpQueryClient.layer({ url: config.indexerClientConnection.indexerHttpUrl }), Layer.mapError((error) => WalletError.WalletError.other(error)));
        },
        connectionLayer() {
            const { indexerClientConnection } = config;
            return ConnectionHelper.createWebSocketUrl(indexerClientConnection.indexerHttpUrl, indexerClientConnection.indexerWsUrl).pipe(Either.flatMap((url) => WsURL.make(url)), Either.match({
                onLeft: (error) => Layer.fail(error),
                onRight: (url) => WsSubscriptionClient.layer({ url }),
            }), Layer.mapError((e) => new WalletError.SyncWalletError({ message: 'Failed to to obtain correct indexer URLs', cause: e })));
        },
        subscribeWallet(state) {
            const { appliedIndex } = state.progress;
            return pipe(DustLedgerEvents.run({
                id: Number(appliedIndex),
            }), Stream.mapEffect((subscription) => pipe(Schema.decodeUnknownEither(SyncEventsUpdateSchema)(subscription.dustLedgerEvents), Either.mapLeft((err) => new WalletError.SyncWalletError(err)), EitherOps.toEffect)), Stream.mapError((error) => new WalletError.SyncWalletError(error)));
        },
    };
};
export const makeDefaultSyncCapability = () => {
    return {
        applyUpdate(state, wrappedUpdate) {
            const { updates, secretKeys } = wrappedUpdate;
            // Nothing to update yet
            if (updates.length === 0) {
                return state;
            }
            const lastUpdate = updates.at(-1);
            const nextIndex = BigInt(lastUpdate.id);
            const highestRelevantWalletIndex = BigInt(lastUpdate.maxId);
            // in case the nextIndex is less than or equal to the current appliedIndex
            // just update highestRelevantWalletIndex
            if (nextIndex <= state.progress.appliedIndex) {
                return state.updateProgress({ highestRelevantWalletIndex, isConnected: true });
            }
            const events = updates.map((u) => u.raw).filter((event) => event !== null);
            return secretKeys((keys) => state
                .applyEvents(keys, events, wrappedUpdate.timestamp)
                .updateProgress({ appliedIndex: nextIndex, highestRelevantWalletIndex, isConnected: true }));
        },
    };
};
export const makeSimulatorSyncService = (config) => {
    return {
        updates: (_state, secretKey) => config.simulator.state$.pipe(Stream.map((state) => ({ update: state, secretKey }))),
        blockData: () => {
            return Effect.gen(function* () {
                const state = yield* config.simulator.getLatestState();
                const timestamp = DateOps.secondsToDate(state.lastTxNumber);
                return {
                    hash: yield* Simulator.blockHash(timestamp),
                    height: Number(state.lastTxNumber),
                    ledgerParameters: state.ledger.parameters,
                    timestamp,
                };
            });
        },
    };
};
export const makeSimulatorSyncCapability = () => ({
    applyUpdate: (state, update) => state
        .applyEvents(update.secretKey, update.update.lastTxResult?.events || [], DateOps.secondsToDate(update.update.lastTxNumber))
        .updateProgress({ appliedIndex: update.update.lastTxNumber }),
});
