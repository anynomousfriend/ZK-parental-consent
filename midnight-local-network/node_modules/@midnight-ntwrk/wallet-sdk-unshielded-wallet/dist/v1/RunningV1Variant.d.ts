import { Effect, Scope, Stream } from 'effect';
import { WalletRuntimeError, Variant, StateChange } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { SerializationCapability } from './Serialization.js';
import { SyncCapability, SyncService } from './Sync.js';
import { WalletSyncUpdate } from './SyncSchema.js';
import { TransactingCapability, TokenTransfer, FinalizedTransactionBalanceResult, UnboundTransactionBalanceResult, UnprovenTransactionBalanceResult } from './Transacting.js';
import { UnboundTransaction } from './TransactionOps.js';
import { WalletError } from './WalletError.js';
import { CoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';
import { CoinSelection } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { CoreWallet } from './CoreWallet.js';
import { TransactionHistoryService } from './TransactionHistory.js';
import * as ledger from '@midnight-ntwrk/ledger-v7';
export declare namespace RunningV1Variant {
    type Context<TSerialized, TSyncUpdate> = {
        serializationCapability: SerializationCapability<CoreWallet, TSerialized>;
        syncService: SyncService<CoreWallet, TSyncUpdate>;
        syncCapability: SyncCapability<CoreWallet, TSyncUpdate>;
        transactingCapability: TransactingCapability<CoreWallet>;
        coinsAndBalancesCapability: CoinsAndBalancesCapability<CoreWallet>;
        keysCapability: KeysCapability<CoreWallet>;
        coinSelection: CoinSelection<ledger.Utxo>;
        transactionHistoryService: TransactionHistoryService<WalletSyncUpdate>;
    };
    type AnyContext = Context<any, any>;
}
export declare const V1Tag: unique symbol;
export type DefaultRunningV1 = RunningV1Variant<string, WalletSyncUpdate>;
export declare class RunningV1Variant<TSerialized, TSyncUpdate> implements Variant.RunningVariant<typeof V1Tag, CoreWallet> {
    #private;
    readonly __polyTag__: typeof V1Tag;
    readonly state: Stream.Stream<StateChange.StateChange<CoreWallet>, WalletRuntimeError>;
    constructor(scope: Scope.Scope, context: Variant.VariantContext<CoreWallet>, v1Context: RunningV1Variant.Context<TSerialized, TSyncUpdate>);
    startSyncInBackground(): Effect.Effect<void>;
    startSync(): Stream.Stream<void, WalletError, Scope.Scope>;
    balanceFinalizedTransaction(tx: ledger.FinalizedTransaction): Effect.Effect<FinalizedTransactionBalanceResult, WalletError>;
    balanceUnboundTransaction(tx: UnboundTransaction): Effect.Effect<UnboundTransactionBalanceResult, WalletError>;
    balanceUnprovenTransaction(tx: ledger.UnprovenTransaction): Effect.Effect<UnprovenTransactionBalanceResult, WalletError>;
    transferTransaction(outputs: ReadonlyArray<TokenTransfer>, ttl: Date): Effect.Effect<ledger.UnprovenTransaction, WalletError>;
    initSwap(desiredInputs: Record<string, bigint>, desiredOutputs: ReadonlyArray<TokenTransfer>, ttl: Date): Effect.Effect<ledger.UnprovenTransaction, WalletError>;
    signUnprovenTransaction(transaction: ledger.UnprovenTransaction, signSegment: (data: Uint8Array) => ledger.Signature): Effect.Effect<ledger.UnprovenTransaction, WalletError>;
    signUnboundTransaction(transaction: UnboundTransaction, signSegment: (data: Uint8Array) => ledger.Signature): Effect.Effect<UnboundTransaction, WalletError>;
    serializeState(state: CoreWallet): TSerialized;
}
