import * as ledger from '@midnight-ntwrk/ledger-v7';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Either } from 'effect';
import { CoreWallet } from './CoreWallet.js';
import { WalletError } from './WalletError.js';
import { CoinSelection } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { TransactionOps, UnboundTransaction } from './TransactionOps.js';
import { CoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';
export interface TokenTransfer {
    readonly amount: bigint;
    readonly type: ledger.RawTokenType;
    readonly receiverAddress: string;
}
export type FinalizedTransactionBalanceResult = ledger.UnprovenTransaction | undefined;
export type UnboundTransactionBalanceResult = UnboundTransaction | undefined;
export type UnprovenTransactionBalanceResult = ledger.UnprovenTransaction | undefined;
export type TransactingResult<TTransaction, TState> = {
    readonly newState: TState;
    readonly transaction: TTransaction;
};
export interface TransactingCapability<TState> {
    makeTransfer(wallet: CoreWallet, outputs: ReadonlyArray<TokenTransfer>, ttl: Date): Either.Either<TransactingResult<ledger.UnprovenTransaction, TState>, WalletError>;
    initSwap(wallet: CoreWallet, desiredInputs: Record<string, bigint>, outputs: ReadonlyArray<TokenTransfer>, ttl: Date): Either.Either<TransactingResult<ledger.UnprovenTransaction, TState>, WalletError>;
    balanceFinalizedTransaction(wallet: CoreWallet, transaction: ledger.FinalizedTransaction): Either.Either<[FinalizedTransactionBalanceResult, CoreWallet], WalletError>;
    balanceUnboundTransaction(wallet: CoreWallet, transaction: UnboundTransaction): Either.Either<[UnboundTransactionBalanceResult, CoreWallet], WalletError>;
    balanceUnprovenTransaction(wallet: CoreWallet, transaction: ledger.UnprovenTransaction): Either.Either<[UnprovenTransactionBalanceResult, CoreWallet], WalletError>;
    signUnprovenTransaction(transaction: ledger.UnprovenTransaction, signSegment: (data: Uint8Array) => ledger.Signature): Either.Either<ledger.UnprovenTransaction, WalletError>;
    revert(wallet: CoreWallet, transaction: ledger.FinalizedTransaction | UnboundTransaction | ledger.UnprovenTransaction): Either.Either<CoreWallet, WalletError>;
    signUnboundTransaction(transaction: UnboundTransaction, signSegment: (data: Uint8Array) => ledger.Signature): Either.Either<UnboundTransaction, WalletError>;
}
export type DefaultTransactingConfiguration = {
    networkId: NetworkId.NetworkId;
};
export type DefaultTransactingContext = {
    coinSelection: CoinSelection<ledger.Utxo>;
    coinsAndBalancesCapability: CoinsAndBalancesCapability<CoreWallet>;
    keysCapability: KeysCapability<CoreWallet>;
};
export declare const makeDefaultTransactingCapability: (config: DefaultTransactingConfiguration, getContext: () => DefaultTransactingContext) => TransactingCapability<CoreWallet>;
export declare class TransactingCapabilityImplementation implements TransactingCapability<CoreWallet> {
    #private;
    readonly networkId: NetworkId.NetworkId;
    readonly getCoinSelection: () => CoinSelection<ledger.Utxo>;
    readonly txOps: TransactionOps;
    readonly getCoins: () => CoinsAndBalancesCapability<CoreWallet>;
    readonly getKeys: () => KeysCapability<CoreWallet>;
    constructor(networkId: NetworkId.NetworkId, getCoinSelection: () => CoinSelection<ledger.Utxo>, getCoins: () => CoinsAndBalancesCapability<CoreWallet>, getKeys: () => KeysCapability<CoreWallet>, txOps: TransactionOps);
    /**
     * Balances an unbound transaction
     * Note: Unbound transactions are balanced in place and returned
     * @param wallet - The wallet to balance the transaction with
     * @param transaction - The transaction to balance
     * @returns The balanced transaction and the new wallet state if successful, otherwise an error
     */
    balanceUnboundTransaction(wallet: CoreWallet, transaction: UnboundTransaction): Either.Either<[UnboundTransactionBalanceResult, CoreWallet], WalletError>;
    /**
     * Balances an unproven transaction
     * Note: This method does the same thing as balanceUnboundTransaction but is provided for convenience and type safety
     * @param wallet - The wallet to balance the transaction with
     * @param transaction - The transaction to balance
     * @returns The balanced transaction and the new wallet state if successful, otherwise an error
     */
    balanceUnprovenTransaction(wallet: CoreWallet, transaction: ledger.UnprovenTransaction): Either.Either<[UnprovenTransactionBalanceResult, CoreWallet], WalletError>;
    /**
     * Balances a bound transaction
     * Note: In bound transactions we can only balance the guaranteed section in intents
     * @param wallet - The wallet to balance the transaction with
     * @param transaction - The transaction to balance
     * @returns A balancing counterpart transaction (which should be merged with the original transaction )
     * and the new wallet state if successful, otherwise an error
     */
    balanceFinalizedTransaction(wallet: CoreWallet, transaction: ledger.FinalizedTransaction): Either.Either<[FinalizedTransactionBalanceResult, CoreWallet], WalletError>;
    /**
     * Makes a transfer transaction
     * @param wallet - The wallet to make the transfer with
     * @param outputs - The outputs for the transfer
     * @param ttl - The TTL for the transaction
     * @returns The balanced transfer transaction and the new wallet state if successful, otherwise an error
     */
    makeTransfer(wallet: CoreWallet, outputs: ReadonlyArray<TokenTransfer>, ttl: Date): Either.Either<TransactingResult<ledger.UnprovenTransaction, CoreWallet>, WalletError>;
    /**
     * Initializes a swap transaction
     * @param wallet - The wallet to initialize the swap for
     * @param desiredInputs - The desired inputs for the swap
     * @param desiredOutputs - The desired outputs for the swap
     * @param ttl - The TTL for the swap
     * @returns The initialized swap transaction and the new wallet state if successful, otherwise an error
     */
    initSwap(wallet: CoreWallet, desiredInputs: Record<ledger.RawTokenType, bigint>, desiredOutputs: ReadonlyArray<TokenTransfer>, ttl: Date): Either.Either<TransactingResult<ledger.UnprovenTransaction, CoreWallet>, WalletError>;
    signUnprovenTransaction(transaction: ledger.UnprovenTransaction, signSegment: (data: Uint8Array) => ledger.Signature): Either.Either<ledger.UnprovenTransaction, WalletError>;
    signUnboundTransaction(transaction: UnboundTransaction, signSegment: (data: Uint8Array) => ledger.Signature): Either.Either<UnboundTransaction, WalletError>;
    /**
     * Reverts a transaction by rolling back all inputs owned by this wallet
     * @param wallet - The wallet to revert the transaction for
     * @param transaction - The transaction to revert (can be FinalizedTransaction, UnboundTransaction, or UnprovenTransaction)
     * @returns The updated wallet with rolled back UTXOs if successful, otherwise an error
     */
    revert(wallet: CoreWallet, transaction: ledger.FinalizedTransaction | UnboundTransaction | ledger.UnprovenTransaction): Either.Either<CoreWallet, WalletError>;
}
