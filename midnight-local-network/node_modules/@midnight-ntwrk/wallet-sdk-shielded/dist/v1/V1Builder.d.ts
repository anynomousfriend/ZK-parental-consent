import * as ledger from '@midnight-ntwrk/ledger-v7';
import { Either, Types } from 'effect';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Variant, VariantBuilder } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { DefaultProvingConfiguration, ProvingService } from './Proving.js';
import { RunningV1Variant, V1Tag } from './RunningV1Variant.js';
import { SerializationCapability } from './Serialization.js';
import { DefaultSyncContext, DefaultSyncConfiguration, SyncCapability, SyncService, WalletSyncUpdate } from './Sync.js';
import { DefaultTransactingConfiguration, DefaultTransactingContext, TransactingCapability } from './Transacting.js';
import { WalletError } from './WalletError.js';
import { CoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';
import { DefaultSubmissionConfiguration, SubmissionService } from './Submission.js';
import { CoinSelection } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { CoreWallet } from './CoreWallet.js';
import { TransactionHistoryCapability } from './TransactionHistory.js';
export type BaseV1Configuration = {
    networkId: NetworkId.NetworkId;
};
export type DefaultV1Configuration = BaseV1Configuration & DefaultSyncConfiguration & DefaultProvingConfiguration & DefaultTransactingConfiguration & DefaultSubmissionConfiguration;
declare const V1BuilderSymbol: {
    readonly typeId: unique symbol;
};
export type V1Variant<TSerialized, TSyncUpdate, TTransaction, TAuxData> = Variant.Variant<typeof V1Tag, CoreWallet, null, RunningV1Variant<TSerialized, TSyncUpdate, TTransaction, TAuxData>> & {
    deserializeState: (serialized: TSerialized) => Either.Either<CoreWallet, WalletError>;
    coinsAndBalances: CoinsAndBalancesCapability<CoreWallet>;
    keys: KeysCapability<CoreWallet>;
    serialization: SerializationCapability<CoreWallet, null, TSerialized>;
    transactionHistory: TransactionHistoryCapability<CoreWallet, TTransaction>;
};
export type AnyV1Variant = V1Variant<any, any, any, any>;
export type DefaultV1Variant = V1Variant<string, WalletSyncUpdate, ledger.FinalizedTransaction, ledger.ZswapSecretKeys>;
export type TransactionOf<T extends AnyV1Variant> = T extends V1Variant<any, any, infer TTransaction, any> ? TTransaction : never;
export type AuxDataOf<T extends AnyV1Variant> = T extends V1Variant<any, any, any, infer TAuxData> ? TAuxData : never;
export type SerializedStateOf<T extends AnyV1Variant> = T extends V1Variant<infer TSerialized, any, any, any> ? TSerialized : never;
export type DefaultV1Builder = V1Builder<DefaultV1Configuration, RunningV1Variant.Context<string, WalletSyncUpdate, ledger.FinalizedTransaction, ledger.ZswapSecretKeys>, string, WalletSyncUpdate, ledger.FinalizedTransaction, ledger.ZswapSecretKeys>;
export declare class V1Builder<TConfig extends BaseV1Configuration = BaseV1Configuration, TContext extends Partial<RunningV1Variant.AnyContext> = object, TSerialized = never, TSyncUpdate = never, TTransaction = never, TStartAux extends object = object> implements VariantBuilder.VariantBuilder<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>, TConfig> {
    #private;
    constructor(buildState?: V1Builder.PartialBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>);
    withDefaults(): DefaultV1Builder;
    withTransactionType<Transaction>(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, Transaction, TStartAux>;
    withDefaultTransactionType(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>;
    withSyncDefaults(): V1Builder<TConfig & DefaultSyncConfiguration, TContext & DefaultSyncContext, TSerialized, WalletSyncUpdate, TTransaction, ledger.ZswapSecretKeys>;
    withSync<TSyncConfig, TSyncContext extends Partial<RunningV1Variant.AnyContext>, TSyncUpdate, TStartAux extends object>(syncService: (configuration: TSyncConfig, getContext: () => TSyncContext) => SyncService<CoreWallet, TStartAux, TSyncUpdate>, syncCapability: (configuration: TSyncConfig, getContext: () => TSyncContext) => SyncCapability<CoreWallet, TSyncUpdate>): V1Builder<TConfig & TSyncConfig, TContext & TSyncContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withSerializationDefaults(): V1Builder<TConfig, TContext, string, TSyncUpdate, TTransaction, TStartAux>;
    withSerialization<TSerializationConfig, TSerializationContext extends Partial<RunningV1Variant.AnyContext>, TSerialized>(serializationCapability: (configuration: TSerializationConfig, getContext: () => TSerializationContext) => SerializationCapability<CoreWallet, null, TSerialized>): V1Builder<TConfig & TSerializationConfig, TContext & TSerializationContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withTransactingDefaults(this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>): V1Builder<TConfig & DefaultTransactingConfiguration, TContext & DefaultTransactingContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>;
    withTransacting<TTransactingConfig, TTransactingContext extends Partial<RunningV1Variant.AnyContext>>(transactingCapability: (config: TTransactingConfig, getContext: () => TTransactingContext) => TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, TTransaction>): V1Builder<TConfig & TTransactingConfig, TContext & TTransactingContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withCoinSelection<TCoinSelectionConfig, TCoinSelectionContext extends Partial<RunningV1Variant.AnyContext>>(coinSelection: (config: TCoinSelectionConfig, getContext: () => TCoinSelectionContext) => CoinSelection<ledger.QualifiedShieldedCoinInfo>): V1Builder<TConfig & TCoinSelectionConfig, TContext & TCoinSelectionContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withCoinSelectionDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withProving<TProvingConfig, TProvingContext extends Partial<RunningV1Variant.AnyContext>>(provingService: (config: TProvingConfig, getContext: () => TProvingContext) => ProvingService<TTransaction>): V1Builder<TConfig & TProvingConfig, TContext & TProvingContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withProvingDefaults(this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>): V1Builder<TConfig & DefaultProvingConfiguration, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>;
    withCoinsAndBalancesDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withCoinsAndBalances<TBalancesConfig, TBalancesContext extends Partial<RunningV1Variant.AnyContext>>(coinsAndBalancesCapability: (configuration: TBalancesConfig, getContext: () => TBalancesContext) => CoinsAndBalancesCapability<CoreWallet>): V1Builder<TConfig & TBalancesConfig, TContext & TBalancesContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withTransactionHistoryDefaults(this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>;
    withTransactionHistory<TTransactionHistoryConfig, TTransactionHistoryContext extends Partial<RunningV1Variant.AnyContext>>(transactionHistoryCapability: (configuration: TTransactionHistoryConfig, getContext: () => TTransactionHistoryContext) => TransactionHistoryCapability<CoreWallet, TTransaction>): V1Builder<TConfig & TTransactionHistoryConfig, TContext & TTransactionHistoryContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withKeysDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withKeys<TKeysConfig, TKeysContext extends Partial<RunningV1Variant.AnyContext>>(keysCapability: (configuration: TKeysConfig, getContext: () => TKeysContext) => KeysCapability<CoreWallet>): V1Builder<TConfig & TKeysConfig, TContext & TKeysContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withSubmission<TSubmissionConfig, TSubmissionContext extends Partial<RunningV1Variant.AnyContext>>(submissionService: (config: TSubmissionConfig, getContext: () => TSubmissionContext) => SubmissionService<TTransaction>): V1Builder<TConfig & TSubmissionConfig, TContext & TSubmissionContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;
    withSubmissionDefaults(this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>): V1Builder<TConfig & DefaultSubmissionConfiguration, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>;
    build(this: V1Builder<TConfig, RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux>, TSerialized, TSyncUpdate, TTransaction, TStartAux>, configuration: TConfig): V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>;
}
/** @internal */
declare namespace V1Builder {
    type HasSync<TConfig, TContext, TSyncUpdate, TStartAux> = {
        readonly syncService: (configuration: TConfig, getContext: () => TContext) => SyncService<CoreWallet, TStartAux, TSyncUpdate>;
        readonly syncCapability: (configuration: TConfig, getContext: () => TContext) => SyncCapability<CoreWallet, TSyncUpdate>;
    };
    type HasTransacting<TConfig, TContext, TTransaction> = {
        readonly transactingCapability: (configuration: TConfig, getContext: () => TContext) => TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, TTransaction>;
    };
    type HasCoinSelection<TConfig, TContext> = {
        readonly coinSelection: (configuration: TConfig, getContext: () => TContext) => CoinSelection<ledger.QualifiedShieldedCoinInfo>;
    };
    type HasSerialization<TConfig, TContext, TSerialized> = {
        readonly serializationCapability: (configuration: TConfig, getContext: () => TContext) => SerializationCapability<CoreWallet, null, TSerialized>;
    };
    type HasProving<TConfig, TContext, TTransaction> = {
        readonly provingService: (configuration: TConfig, getContext: () => TContext) => ProvingService<TTransaction>;
    };
    type HasCoinsAndBalances<TConfig, TContext> = {
        readonly coinsAndBalancesCapability: (configuration: TConfig, getContext: () => TContext) => CoinsAndBalancesCapability<CoreWallet>;
    };
    type HasTransactionHistory<TConfig, TContext, TTransaction> = {
        readonly transactionHistoryCapability: (configuration: TConfig, getContext: () => TContext) => TransactionHistoryCapability<CoreWallet, TTransaction>;
    };
    type HasKeys<TConfig, TContext> = {
        readonly keysCapability: (configuration: TConfig, getContext: () => TContext) => KeysCapability<CoreWallet>;
    };
    type HasSubmission<TConfig, TContext, TTransaction> = {
        readonly submissionService: (configuration: TConfig, getContext: () => TContext) => SubmissionService<TTransaction>;
    };
    /**
     * The internal build state of {@link V1Builder}.
     */
    type FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> = Types.Simplify<HasSync<TConfig, TContext, TSyncUpdate, TStartAux> & HasSerialization<TConfig, TContext, TSerialized> & HasTransacting<TConfig, TContext, TTransaction> & HasCoinSelection<TConfig, TContext> & HasProving<TConfig, TContext, TTransaction> & HasSubmission<TConfig, TContext, TTransaction> & HasCoinsAndBalances<TConfig, TContext> & HasKeys<TConfig, TContext> & HasTransactionHistory<TConfig, TContext, TTransaction>>;
    type PartialBuildState<TConfig = object, TContext = object, TSerialized = never, TSyncUpdate = never, TTransaction = never, TStartAux = object> = {
        [K in keyof FullBuildState<never, never, never, never, never, never>]?: FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>[K] | undefined;
    };
    /**
     * Utility interface that manages the type variance of {@link V1Builder}.
     */
    interface Variance<R> {
        readonly [V1BuilderSymbol.typeId]: {
            readonly _R: Types.Covariant<R>;
        };
    }
}
export {};
