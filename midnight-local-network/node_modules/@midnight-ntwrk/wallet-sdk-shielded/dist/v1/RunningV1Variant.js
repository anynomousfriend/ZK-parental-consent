import { Effect, pipe, Scope, Stream, SubscriptionRef, Schedule, Duration, Sink, Console } from 'effect';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { StateChange, VersionChangeType, } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { OtherWalletError } from './WalletError.js';
const progress = (state) => {
    const appliedIndex = state.progress?.appliedIndex ?? 0n;
    const highestRelevantWalletIndex = state.progress?.highestRelevantWalletIndex ?? 0n;
    const highestIndex = state.progress?.highestIndex ?? 0n;
    const highestRelevantIndex = state.progress?.highestRelevantIndex ?? 0n;
    const sourceGap = highestIndex - highestRelevantIndex;
    const applyGap = highestRelevantWalletIndex - appliedIndex;
    return [StateChange.ProgressUpdate({ sourceGap, applyGap })];
};
const protocolVersionChange = (previous, current) => {
    return previous.protocolVersion != current.protocolVersion
        ? [
            StateChange.VersionChange({
                change: VersionChangeType.Version({
                    version: ProtocolVersion.ProtocolVersion(current.protocolVersion),
                }),
            }),
        ]
        : [];
};
export const V1Tag = Symbol('V1');
export class RunningV1Variant {
    __polyTag__ = V1Tag;
    #scope;
    #context;
    #v1Context;
    state;
    constructor(scope, context, v1Context) {
        this.#scope = scope;
        this.#context = context;
        this.#v1Context = v1Context;
        this.state = Stream.fromEffect(context.stateRef.get).pipe(Stream.flatMap((initialState) => context.stateRef.changes.pipe(Stream.mapAccum(initialState, (previous, current) => {
            return [current, [previous, current]];
        }))), Stream.mapConcat(([previous, current]) => {
            // TODO: emit progress only upon actual change
            return [
                StateChange.State({ state: current }),
                ...progress(current),
                ...protocolVersionChange(previous, current),
            ];
        }));
    }
    startSyncInBackground(startAux) {
        return this.startSync(startAux).pipe(Stream.runScoped(Sink.drain), Effect.forkScoped, Effect.provideService(Scope.Scope, this.#scope));
    }
    startSync(startAux) {
        return pipe(SubscriptionRef.get(this.#context.stateRef), Stream.fromEffect, Stream.flatMap((state) => this.#v1Context.syncService.updates(state, startAux)), Stream.mapEffect((update) => {
            return SubscriptionRef.updateEffect(this.#context.stateRef, (state) => Effect.try({
                try: () => this.#v1Context.syncCapability.applyUpdate(state, update),
                catch: (err) => new OtherWalletError({
                    message: 'Error while applying sync update',
                    cause: err,
                }),
            }));
        }), Stream.tapError((error) => Console.error(error)), Stream.retry(pipe(Schedule.exponential(Duration.seconds(1), 2), Schedule.map((delay) => {
            const maxDelay = Duration.minutes(2);
            const jitter = Duration.millis(Math.floor(Math.random() * 1000));
            const delayWithJitter = Duration.toMillis(delay) + Duration.toMillis(jitter);
            return Duration.millis(Math.min(delayWithJitter, Duration.toMillis(maxDelay)));
        }))));
    }
    balanceTransaction(secretKeys, tx) {
        return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
            return pipe(this.#v1Context.transactingCapability.balanceTransaction(secretKeys, state, tx), EitherOps.toEffect);
        });
    }
    transferTransaction(secretKeys, outputs) {
        return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
            return pipe(this.#v1Context.transactingCapability.makeTransfer(secretKeys, state, outputs), EitherOps.toEffect);
        });
    }
    initSwap(secretKeys, desiredInputs, desiredOutputs) {
        return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
            return pipe(this.#v1Context.transactingCapability.initSwap(secretKeys, state, desiredInputs, desiredOutputs), EitherOps.toEffect);
        });
    }
    finalizeTransaction(transaction) {
        return this.#v1Context.provingService
            .prove(transaction)
            .pipe(Effect.tapError(() => SubscriptionRef.updateEffect(this.#context.stateRef, (state) => EitherOps.toEffect(this.#v1Context.transactingCapability.revertTransaction(state, transaction)))));
    }
    submitTransaction = ((transaction, waitForStatus = 'InBlock') => {
        return this.#v1Context.submissionService
            .submitTransaction(transaction, waitForStatus)
            .pipe(Effect.tapError(() => SubscriptionRef.updateEffect(this.#context.stateRef, (state) => EitherOps.toEffect(this.#v1Context.transactingCapability.revertTransaction(state, transaction)))));
    });
    serializeState(state) {
        return this.#v1Context.serializationCapability.serialize(state);
    }
}
