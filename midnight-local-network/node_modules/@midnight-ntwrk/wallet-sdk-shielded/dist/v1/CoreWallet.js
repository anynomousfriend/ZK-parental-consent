// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v7';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Either, Iterable, pipe, Record, Array as Arr } from 'effect';
import { createSyncProgress } from './SyncProgress.js';
import { InvalidCoinHashesError } from './WalletError.js';
export const PublicKeys = {
    fromSecretKeys: (secretKeys) => {
        return {
            coinPublicKey: secretKeys.coinPublicKey,
            encryptionPublicKey: secretKeys.encryptionPublicKey,
        };
    },
};
export const CoinHashesMap = {
    empty: {},
    pickAllCoins(state) {
        return [...state.coins, ...state.pendingOutputs.values().map(([coin]) => coin)];
    },
    assertValid(map, state) {
        const coins = CoinHashesMap.pickAllCoins(state);
        const coinNonces = new Set(Iterable.map(coins, (coin) => coin.nonce));
        const definedNonces = new Set(Object.keys(map));
        const missingNonces = coinNonces.difference(definedNonces);
        return missingNonces.size === 0 ? Either.void : Either.left(missingNonces);
    },
    updateWithCoins(secretKeys, existing, coins) {
        return Record.fromIterableWith(coins, (coin) => [
            coin.nonce,
            existing[coin.nonce] ?? {
                commitment: ledger.coinCommitment(coin, secretKeys.coinPublicKey),
                nullifier: ledger.coinNullifier(coin, secretKeys.coinSecretKey),
            },
        ]);
    },
    updateWithNewCoins(secretKeys, existing, coins) {
        const newMap = CoinHashesMap.updateWithCoins(secretKeys, CoinHashesMap.empty, coins);
        return Record.union(existing, newMap, (a) => a);
    },
    init(secretKeys, coins) {
        return CoinHashesMap.updateWithCoins(secretKeys, {}, coins);
    },
};
export const CoreWallet = {
    init(localState, secretKeys, networkId) {
        const publicKeys = PublicKeys.fromSecretKeys(secretKeys);
        const coinHashes = CoinHashesMap.init(secretKeys, CoinHashesMap.pickAllCoins(localState));
        const progress = createSyncProgress();
        const protocolVersion = ProtocolVersion.MinSupportedVersion;
        return { state: localState, publicKeys, networkId, coinHashes, txHistoryArray: [], progress, protocolVersion };
    },
    empty(publicKeys, networkId) {
        return {
            state: new ledger.ZswapLocalState(),
            publicKeys,
            networkId,
            coinHashes: CoinHashesMap.empty,
            txHistoryArray: [],
            progress: createSyncProgress(),
            protocolVersion: ProtocolVersion.MinSupportedVersion,
        };
    },
    restore(localState, secretKeys, txHistory, syncProgress, protocolVersion, networkId) {
        const publicKeys = PublicKeys.fromSecretKeys(secretKeys);
        const coinHashes = CoinHashesMap.init(secretKeys, CoinHashesMap.pickAllCoins(localState));
        return {
            state: localState,
            publicKeys,
            networkId,
            coinHashes,
            txHistoryArray: txHistory,
            progress: createSyncProgress(syncProgress),
            protocolVersion: ProtocolVersion.ProtocolVersion(protocolVersion),
        };
    },
    restoreWithCoinHashes(publicKeys, localState, txHistory, coinHashes, syncProgress, protocolVersion, networkId) {
        return CoinHashesMap.assertValid(coinHashes, localState).pipe(Either.mapBoth({
            onLeft: (missingNonces) => new InvalidCoinHashesError({ message: 'Missing coin hashes for coins present in the state', missingNonces }),
            onRight: () => ({
                state: localState,
                publicKeys,
                networkId,
                coinHashes,
                txHistoryArray: txHistory,
                progress: createSyncProgress(syncProgress),
                protocolVersion: ProtocolVersion.ProtocolVersion(protocolVersion),
            }),
        }));
    },
    initEmpty(keys, networkId) {
        return this.empty(PublicKeys.fromSecretKeys(keys), networkId);
    },
    applyCollapsedUpdate(wallet, collapsed) {
        const newState = wallet.state.applyCollapsedUpdate(collapsed);
        return { ...wallet, state: newState };
    },
    apply(wallet, secretKeys, offer) {
        const newState = wallet.state.apply(secretKeys, offer);
        const newCoinHashes = CoinHashesMap.updateWithCoins(secretKeys, wallet.coinHashes, CoinHashesMap.pickAllCoins(newState));
        return { ...wallet, state: newState, coinHashes: newCoinHashes };
    },
    replayEvents(wallet, secretKeys, events) {
        const newState = wallet.state.replayEvents(secretKeys, events);
        const newCoinHashes = CoinHashesMap.updateWithCoins(secretKeys, wallet.coinHashes, CoinHashesMap.pickAllCoins(newState));
        return { ...wallet, state: newState, coinHashes: newCoinHashes };
    },
    updateProgress(wallet, { appliedIndex, highestRelevantWalletIndex, highestIndex, highestRelevantIndex, isConnected, }) {
        const updatedProgress = createSyncProgress({
            appliedIndex: appliedIndex ?? wallet.progress.appliedIndex,
            highestRelevantWalletIndex: highestRelevantWalletIndex ?? wallet.progress.highestRelevantWalletIndex,
            highestIndex: highestIndex ?? wallet.progress.highestIndex,
            highestRelevantIndex: highestRelevantIndex ?? wallet.progress.highestRelevantIndex,
            isConnected: isConnected ?? wallet.progress.isConnected,
        });
        return { ...wallet, progress: updatedProgress };
    },
    addTransaction(wallet, tx) {
        return { ...wallet, txHistoryArray: [...wallet.txHistoryArray, tx] };
    },
    /* not implemented until this is done https://shielded.atlassian.net/browse/PM-19678 */
    revertTransaction(wallet, _tx) {
        return wallet;
    },
    updateTxHistory(wallet, newTxs) {
        return { ...wallet, txHistoryArray: [...wallet.txHistoryArray, ...newTxs] };
    },
    spendCoins(wallet, secretKeys, coins, segment) {
        const [offers, newLocalState] = pipe(coins, Arr.reduce([[], wallet.state], ([accOffers, localState], coinToSpend) => {
            const [nextState, newInput] = localState.spend(secretKeys, coinToSpend, segment);
            const inputOffer = ledger.ZswapOffer.fromInput(newInput, coinToSpend.type, coinToSpend.value);
            return [accOffers.concat([inputOffer]), nextState];
        }));
        const updated = { ...wallet, state: newLocalState };
        return [offers, updated];
    },
    watchCoins(wallet, secretKeys, coins) {
        const newLocalState = coins.reduce((localState, coin) => localState.watchFor(wallet.publicKeys.coinPublicKey, coin), wallet.state);
        const newCoinHashes = CoinHashesMap.updateWithNewCoins(secretKeys, wallet.coinHashes, coins);
        return { ...wallet, state: newLocalState, coinHashes: newCoinHashes };
    },
};
