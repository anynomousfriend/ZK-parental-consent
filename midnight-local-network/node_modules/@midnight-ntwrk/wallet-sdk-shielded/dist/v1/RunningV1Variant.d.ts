import * as ledger from '@midnight-ntwrk/ledger-v7';
import { Effect, Scope, Stream } from 'effect';
import { WalletRuntimeError, Variant, StateChange } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { ProvingService } from './Proving.js';
import { SerializationCapability } from './Serialization.js';
import { EventsSyncUpdate, SyncCapability, SyncService } from './Sync.js';
import { TransactingCapability, TokenTransfer, BalancingResult } from './Transacting.js';
import { WalletError } from './WalletError.js';
import { CoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';
import { SubmissionService, SubmitTransactionMethod } from './Submission.js';
import { CoinSelection } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { CoreWallet } from './CoreWallet.js';
import { TransactionHistoryCapability } from './TransactionHistory.js';
export declare namespace RunningV1Variant {
    type Context<TSerialized, TSyncUpdate, TTransaction, TStartAux> = {
        serializationCapability: SerializationCapability<CoreWallet, null, TSerialized>;
        syncService: SyncService<CoreWallet, TStartAux, TSyncUpdate>;
        syncCapability: SyncCapability<CoreWallet, TSyncUpdate>;
        transactingCapability: TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, TTransaction>;
        provingService: ProvingService<TTransaction>;
        coinsAndBalancesCapability: CoinsAndBalancesCapability<CoreWallet>;
        keysCapability: KeysCapability<CoreWallet>;
        submissionService: SubmissionService<TTransaction>;
        coinSelection: CoinSelection<ledger.QualifiedShieldedCoinInfo>;
        transactionHistoryCapability: TransactionHistoryCapability<CoreWallet, TTransaction>;
    };
    type AnyContext = Context<any, any, any, any>;
}
export declare const V1Tag: unique symbol;
export type DefaultRunningV1 = RunningV1Variant<string, EventsSyncUpdate, ledger.FinalizedTransaction, ledger.ZswapSecretKeys>;
export declare class RunningV1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux> implements Variant.RunningVariant<typeof V1Tag, CoreWallet> {
    #private;
    readonly __polyTag__: typeof V1Tag;
    readonly state: Stream.Stream<StateChange.StateChange<CoreWallet>, WalletRuntimeError>;
    constructor(scope: Scope.Scope, context: Variant.VariantContext<CoreWallet>, v1Context: RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux>);
    startSyncInBackground(startAux: TStartAux): Effect.Effect<void>;
    startSync(startAux: TStartAux): Stream.Stream<void, WalletError, Scope.Scope>;
    balanceTransaction(secretKeys: ledger.ZswapSecretKeys, tx: ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>): Effect.Effect<BalancingResult, WalletError>;
    transferTransaction(secretKeys: ledger.ZswapSecretKeys, outputs: ReadonlyArray<TokenTransfer>): Effect.Effect<ledger.UnprovenTransaction, WalletError>;
    initSwap(secretKeys: ledger.ZswapSecretKeys, desiredInputs: Record<ledger.RawTokenType, bigint>, desiredOutputs: ReadonlyArray<TokenTransfer>): Effect.Effect<ledger.UnprovenTransaction, WalletError>;
    finalizeTransaction(transaction: ledger.UnprovenTransaction): Effect.Effect<TTransaction, WalletError>;
    submitTransaction: SubmitTransactionMethod<TTransaction>;
    serializeState(state: CoreWallet): TSerialized;
}
