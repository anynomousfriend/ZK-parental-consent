// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v7';
import { Array as Arr, Either, Option, pipe, Record } from 'effect';
import { ArrayOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { CoreWallet } from './CoreWallet.js';
import { AddressError, InsufficientFundsError, OtherWalletError } from './WalletError.js';
import { getBalanceRecipe, Imbalances, InsufficientFundsError as BalancingInsufficientFundsError, } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { MidnightBech32m, ShieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { ShieldedCostModel, TransactionImbalances } from './TransactionImbalances.js';
import { TransactionOps } from './TransactionOps.js';
export const makeDefaultTransactingCapability = (config, getContext) => {
    return new TransactingCapabilityImplementation(config.networkId, () => getContext().coinSelection, () => getContext().coinsAndBalancesCapability, () => getContext().keysCapability, TransactionOps.default);
};
export const makeSimulatorTransactingCapability = (config, getContext) => {
    return new TransactingCapabilityImplementation(config.networkId, () => getContext().coinSelection, () => getContext().coinsAndBalancesCapability, () => getContext().keysCapability, TransactionOps.proofErased);
};
export class TransactingCapabilityImplementation {
    networkId;
    getCoinSelection;
    txOps;
    getCoins;
    getKeys;
    constructor(networkId, getCoinSelection, getCoins, getKeys, txOps) {
        this.getCoins = getCoins;
        this.networkId = networkId;
        this.getCoinSelection = getCoinSelection;
        this.getKeys = getKeys;
        this.txOps = txOps;
    }
    balanceTransaction(secretKeys, state, tx) {
        return Either.gen(this, function* () {
            const coinSelection = this.getCoinSelection();
            const initialImbalances = this.txOps.getImbalances(tx);
            if (TransactionImbalances.areBalanced(initialImbalances)) {
                return [undefined, state];
            }
            const { newState: afterFallible, offer: maybeFallible } = yield* this.balanceFallibleSection(secretKeys, state, initialImbalances, coinSelection);
            const { newState: afterGuaranteed, offer: guaranteed } = yield* this.#balanceGuaranteedSection(secretKeys, afterFallible, initialImbalances, coinSelection, Imbalances.empty());
            return [ledger.Transaction.fromParts(this.networkId, guaranteed, maybeFallible), afterGuaranteed];
        });
    }
    makeTransfer(secretKeys, state, transfers) {
        return Either.gen(this, function* () {
            const positiveTransfers = yield* pipe(transfers, Arr.filter((t) => t.amount > 0n), Arr.match({
                onEmpty: () => Either.left(new OtherWalletError({
                    message: 'The amount needs to be positive',
                })),
                onNonEmpty: (nonEmpty) => Either.right(nonEmpty),
            }));
            const networkId = this.networkId;
            const { initialOffersAndCoins, selfCoins } = yield* this.#processDesiredOutputs(state, positiveTransfers);
            const offerToBalance = pipe(initialOffersAndCoins, Arr.map((o) => o.outputOffer), ArrayOps.fold((a, b) => a.merge(b)));
            const unprovenTxToBalance = ledger.Transaction.fromParts(networkId, offerToBalance);
            const imbalances = TransactionOps.unproven.getImbalances(unprovenTxToBalance);
            const { offer, newState } = yield* this.#balanceGuaranteedSection(secretKeys, state, imbalances, this.getCoinSelection(), Imbalances.empty());
            const finalState = CoreWallet.watchCoins(newState, secretKeys, selfCoins);
            const finalTx = unprovenTxToBalance.merge(ledger.Transaction.fromParts(networkId, offer));
            return [finalTx, finalState];
        });
    }
    initSwap(secretKeys, state, desiredInputs, desiredOutputs) {
        return Either.gen(this, function* () {
            const outputsValid = desiredOutputs.every((output) => output.amount > 0n);
            if (!outputsValid) {
                return yield* Either.left(new OtherWalletError({
                    message: 'The amount needs to be positive',
                }));
            }
            const inputsValid = Object.entries(desiredInputs).every(([, amount]) => amount > 0n);
            if (!inputsValid) {
                return yield* Either.left(new OtherWalletError({
                    message: 'The input amounts need to be positive',
                }));
            }
            const outputsParseResult = yield* this.#processDesiredOutputsPossiblyEmpty(state, desiredOutputs);
            const inputsParseResult = Imbalances.fromEntries(Record.toEntries(desiredInputs));
            const networkId = this.networkId;
            const { offer, newState } = yield* this.#balanceGuaranteedSection(secretKeys, state, TransactionImbalances.empty(), this.getCoinSelection(), inputsParseResult);
            const finalState = CoreWallet.watchCoins(newState, secretKeys, outputsParseResult.selfCoins);
            const balancingTx = ledger.Transaction.fromParts(networkId, offer);
            const finalTx = outputsParseResult.unprovenTxToBalance
                ? outputsParseResult.unprovenTxToBalance.merge(balancingTx)
                : balancingTx;
            return [finalTx, finalState];
        });
    }
    revertTransaction(state, transaction) {
        return Either.try({
            try: () => {
                return CoreWallet.revertTransaction(state, transaction);
            },
            catch: (err) => {
                return new OtherWalletError({
                    message: `Error while reverting transaction ${transaction.identifiers().at(0)}`,
                    cause: err,
                });
            },
        });
    }
    #prepareOffer(secretKeys, state, recipe, segment) {
        const [inputOffers, stateAfterSpends] = CoreWallet.spendCoins(state, secretKeys, recipe.inputs, segment);
        const stateAfterWatches = CoreWallet.watchCoins(stateAfterSpends, secretKeys, recipe.outputs);
        const outputOffers = recipe.outputs.map((coin) => {
            const output = ledger.ZswapOutput.new(coin, segment, this.getKeys().getCoinPublicKey(state).toHexString(), this.getKeys().getEncryptionPublicKey(state).toHexString());
            return ledger.ZswapOffer.fromOutput(output, coin.type, coin.value);
        });
        return pipe(Arr.appendAll(inputOffers, outputOffers), Arr.match({
            onEmpty: () => Option.none(),
            onNonEmpty: (nonEmpty) => pipe(nonEmpty, ArrayOps.fold((a, b) => a.merge(b)), Option.some),
        }), Option.map((offer) => ({ offer, newState: stateAfterWatches })));
    }
    balanceFallibleSection(secretKeys, state, imbalances, coinSelection) {
        return Either.try({
            try: () => {
                const fallibleBalanceRecipe = getBalanceRecipe({
                    coins: this.getCoins()
                        .getAvailableCoins(state)
                        .map((c) => c.coin),
                    initialImbalances: imbalances.fallible,
                    transactionCostModel: ShieldedCostModel,
                    feeTokenType: '',
                    coinSelection,
                    createOutput: (coin) => ledger.createShieldedCoinInfo(coin.type, coin.value),
                    isCoinEqual: (a, b) => a.type === b.type && a.value === b.value,
                });
                return pipe(this.#prepareOffer(secretKeys, state, fallibleBalanceRecipe, 1), Option.match({
                    onNone: () => ({
                        newState: state,
                        offer: undefined,
                    }),
                    onSome: (res) => res,
                }));
            },
            catch: (err) => {
                if (err instanceof BalancingInsufficientFundsError) {
                    return new InsufficientFundsError({
                        message: 'Insufficient funds',
                        tokenType: err.tokenType,
                        amount: imbalances.fallible.get(err.tokenType) ?? 0n,
                    });
                }
                else {
                    return new OtherWalletError({
                        message: 'Balancing fallible section failed',
                        cause: err,
                    });
                }
            },
        });
    }
    #balanceGuaranteedSection(secretKeys, state, imbalances, coinSelection, targetImbalances) {
        return Either.gen(this, function* () {
            const balanceRecipe = yield* Either.try({
                try: () => getBalanceRecipe({
                    coins: this.getCoins()
                        .getAvailableCoins(state)
                        .map((c) => c.coin),
                    initialImbalances: imbalances.guaranteed,
                    transactionCostModel: ShieldedCostModel,
                    feeTokenType: '',
                    coinSelection,
                    createOutput: (coin) => ledger.createShieldedCoinInfo(coin.type, coin.value),
                    isCoinEqual: (a, b) => a.nonce === b.nonce,
                    targetImbalances,
                }),
                catch: (err) => {
                    if (err instanceof BalancingInsufficientFundsError) {
                        return new InsufficientFundsError({
                            message: 'Insufficient funds',
                            tokenType: err.tokenType,
                            amount: imbalances.guaranteed.get(err.tokenType) ?? 0n,
                        });
                    }
                    else {
                        return new OtherWalletError({
                            message: 'Balancing guaranteed section failed',
                            cause: err,
                        });
                    }
                },
            });
            return yield* pipe(this.#prepareOffer(secretKeys, state, balanceRecipe, 0), Either.fromOption(() => {
                return new OtherWalletError({
                    message: 'Could not create a valid guaranteed offer',
                });
            }));
        });
    }
    #parseAddress(addr) {
        return Either.try({
            try: () => {
                const repr = MidnightBech32m.parse(addr);
                return ShieldedAddress.codec.decode(this.networkId, repr);
            },
            catch: (err) => {
                return new AddressError({
                    message: `Address parsing error: ${addr}`,
                    originalAddress: addr,
                    cause: err,
                });
            },
        });
    }
    #processDesiredOutputs(state, transfers) {
        return Either.gen(this, function* () {
            const initialOffersAndCoins = yield* pipe(transfers, Arr.map((transfer) => {
                return pipe(this.#parseAddress(transfer.receiverAddress), Either.map((address) => {
                    const coin = ledger.createShieldedCoinInfo(transfer.type, transfer.amount);
                    const output = ledger.ZswapOutput.new(coin, 0, address.coinPublicKey.toHexString(), address.encryptionPublicKey.toHexString());
                    const outputOffer = ledger.ZswapOffer.fromOutput(output, transfer.type, transfer.amount);
                    return {
                        coin,
                        outputOffer,
                        isForSelf: address.coinPublicKey.equals(this.getKeys().getCoinPublicKey(state)),
                    };
                }));
            }), Either.all);
            const selfCoins = Arr.flatMap(initialOffersAndCoins, ({ coin, isForSelf }) => {
                if (isForSelf) {
                    return [coin];
                }
                else {
                    return [];
                }
            });
            return { initialOffersAndCoins, selfCoins };
        });
    }
    #processDesiredOutputsPossiblyEmpty(state, desiredOutputs) {
        return pipe(desiredOutputs, Arr.match({
            onEmpty: () => {
                return Either.right({
                    imbalances: TransactionImbalances.empty(),
                    selfCoins: [],
                    unprovenTxToBalance: null,
                });
            },
            onNonEmpty: (desiredOutputs) => {
                return pipe(this.#processDesiredOutputs(state, desiredOutputs), Either.map(({ initialOffersAndCoins, selfCoins }) => {
                    const networkId = this.networkId;
                    const offerToBalance = pipe(initialOffersAndCoins, Arr.map((o) => o.outputOffer), ArrayOps.fold((a, b) => a.merge(b)));
                    const unprovenTxToBalance = ledger.Transaction.fromParts(networkId, offerToBalance);
                    const imbalances = TransactionOps.unproven.getImbalances(unprovenTxToBalance);
                    return {
                        imbalances,
                        selfCoins,
                        unprovenTxToBalance,
                    };
                }));
            },
        }));
    }
}
