import * as ledger from '@midnight-ntwrk/ledger-v7';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Either } from 'effect';
import { SyncProgress, SyncProgressData } from './SyncProgress.js';
import { WalletError } from './WalletError.js';
export type PublicKeys = {
    coinPublicKey: ledger.CoinPublicKey;
    encryptionPublicKey: ledger.EncPublicKey;
};
export declare const PublicKeys: {
    fromSecretKeys: (secretKeys: ledger.ZswapSecretKeys) => PublicKeys;
};
export type CoinHashesMap = Readonly<Record<ledger.Nonce, {
    nullifier: ledger.Nullifier;
    commitment: ledger.CoinCommitment;
}>>;
export declare const CoinHashesMap: {
    empty: {};
    pickAllCoins(state: ledger.ZswapLocalState): readonly ledger.ShieldedCoinInfo[];
    assertValid(map: CoinHashesMap, state: ledger.ZswapLocalState): Either.Either<void, Set<ledger.Nonce>>;
    updateWithCoins(secretKeys: ledger.ZswapSecretKeys, existing: CoinHashesMap, coins: Iterable<ledger.ShieldedCoinInfo>): CoinHashesMap;
    updateWithNewCoins(secretKeys: ledger.ZswapSecretKeys, existing: CoinHashesMap, coins: Iterable<ledger.ShieldedCoinInfo>): CoinHashesMap;
    init(secretKeys: ledger.ZswapSecretKeys, coins: Iterable<ledger.ShieldedCoinInfo>): CoinHashesMap;
};
export type CoreWallet = Readonly<{
    state: ledger.ZswapLocalState;
    publicKeys: PublicKeys;
    protocolVersion: ProtocolVersion.ProtocolVersion;
    progress: SyncProgress;
    networkId: string;
    txHistoryArray: readonly ledger.FinalizedTransaction[];
    coinHashes: CoinHashesMap;
}>;
export declare const CoreWallet: {
    init(localState: ledger.ZswapLocalState, secretKeys: ledger.ZswapSecretKeys, networkId: string): CoreWallet;
    empty(publicKeys: PublicKeys, networkId: string): CoreWallet;
    restore(localState: ledger.ZswapLocalState, secretKeys: ledger.ZswapSecretKeys, txHistory: readonly ledger.FinalizedTransaction[], syncProgress: Omit<SyncProgressData, "isConnected">, protocolVersion: bigint, networkId: string): CoreWallet;
    restoreWithCoinHashes(publicKeys: PublicKeys, localState: ledger.ZswapLocalState, txHistory: readonly ledger.FinalizedTransaction[], coinHashes: CoinHashesMap, syncProgress: SyncProgressData, protocolVersion: bigint, networkId: string): Either.Either<CoreWallet, WalletError>;
    initEmpty(keys: ledger.ZswapSecretKeys, networkId: string): CoreWallet;
    applyCollapsedUpdate(wallet: CoreWallet, collapsed: ledger.MerkleTreeCollapsedUpdate): CoreWallet;
    apply<TOffer extends ledger.ZswapOffer<ledger.Proofish>>(wallet: CoreWallet, secretKeys: ledger.ZswapSecretKeys, offer: TOffer): CoreWallet;
    replayEvents(wallet: CoreWallet, secretKeys: ledger.ZswapSecretKeys, events: ledger.Event[]): CoreWallet;
    updateProgress(wallet: CoreWallet, { appliedIndex, highestRelevantWalletIndex, highestIndex, highestRelevantIndex, isConnected, }: Partial<SyncProgressData>): CoreWallet;
    addTransaction(wallet: CoreWallet, tx: ledger.FinalizedTransaction): CoreWallet;
    revertTransaction<TTx extends ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>>(wallet: CoreWallet, _tx: TTx): CoreWallet;
    updateTxHistory(wallet: CoreWallet, newTxs: readonly ledger.FinalizedTransaction[]): CoreWallet;
    spendCoins(wallet: CoreWallet, secretKeys: ledger.ZswapSecretKeys, coins: ReadonlyArray<ledger.QualifiedShieldedCoinInfo>, segment: number): [ReadonlyArray<ledger.ZswapOffer<ledger.PreProof>>, CoreWallet];
    watchCoins(wallet: CoreWallet, secretKeys: ledger.ZswapSecretKeys, coins: ReadonlyArray<ledger.ShieldedCoinInfo>): CoreWallet;
};
