import * as ledger from '@midnight-ntwrk/ledger-v7';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Array as Arr, Either } from 'effect';
import { CoreWallet } from './CoreWallet.js';
import { WalletError } from './WalletError.js';
import { CoinSelection } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { TransactionImbalances } from './TransactionImbalances.js';
import { TransactionOps } from './TransactionOps.js';
import { CoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';
export interface TokenTransfer {
    readonly amount: bigint;
    readonly type: ledger.RawTokenType;
    readonly receiverAddress: string;
}
export type BalancingResult = ledger.UnprovenTransaction | undefined;
export interface TransactingCapability<TSecrets, TState, TTransaction> {
    balanceTransaction(secrets: TSecrets, state: TState, tx: ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>): Either.Either<[BalancingResult, TState], WalletError>;
    makeTransfer(secrets: TSecrets, state: TState, outputs: ReadonlyArray<TokenTransfer>): Either.Either<[ledger.UnprovenTransaction, TState], WalletError>;
    initSwap(secrets: TSecrets, state: TState, desiredInputs: Record<ledger.RawTokenType, bigint>, desiredOutputs: ReadonlyArray<TokenTransfer>): Either.Either<[ledger.UnprovenTransaction, TState], WalletError>;
    revertTransaction(state: TState, transaction: TTransaction | ledger.UnprovenTransaction): Either.Either<TState, WalletError>;
}
export type DefaultTransactingConfiguration = {
    networkId: NetworkId.NetworkId;
};
export type DefaultTransactingContext = {
    coinSelection: CoinSelection<ledger.QualifiedShieldedCoinInfo>;
    coinsAndBalancesCapability: CoinsAndBalancesCapability<CoreWallet>;
    keysCapability: KeysCapability<CoreWallet>;
};
export declare const makeDefaultTransactingCapability: (config: DefaultTransactingConfiguration, getContext: () => DefaultTransactingContext) => TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, ledger.FinalizedTransaction>;
export declare const makeSimulatorTransactingCapability: (config: DefaultTransactingConfiguration, getContext: () => DefaultTransactingContext) => TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, ledger.ProofErasedTransaction>;
export declare class TransactingCapabilityImplementation<TTransaction extends ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>> implements TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, TTransaction> {
    #private;
    readonly networkId: NetworkId.NetworkId;
    readonly getCoinSelection: () => CoinSelection<ledger.QualifiedShieldedCoinInfo>;
    readonly txOps: TransactionOps<TTransaction>;
    readonly getCoins: () => CoinsAndBalancesCapability<CoreWallet>;
    readonly getKeys: () => KeysCapability<CoreWallet>;
    constructor(networkId: NetworkId.NetworkId, getCoinSelection: () => CoinSelection<ledger.QualifiedShieldedCoinInfo>, getCoins: () => CoinsAndBalancesCapability<CoreWallet>, getKeys: () => KeysCapability<CoreWallet>, txOps: TransactionOps<TTransaction>);
    balanceTransaction(secretKeys: ledger.ZswapSecretKeys, state: CoreWallet, tx: TTransaction): Either.Either<[BalancingResult, CoreWallet], WalletError>;
    makeTransfer(secretKeys: ledger.ZswapSecretKeys, state: CoreWallet, transfers: Arr.NonEmptyReadonlyArray<TokenTransfer>): Either.Either<[ledger.UnprovenTransaction, CoreWallet], WalletError>;
    initSwap(secretKeys: ledger.ZswapSecretKeys, state: CoreWallet, desiredInputs: Record<ledger.RawTokenType, bigint>, desiredOutputs: ReadonlyArray<TokenTransfer>): Either.Either<[ledger.UnprovenTransaction, CoreWallet], WalletError>;
    revertTransaction(state: CoreWallet, transaction: TTransaction | ledger.UnprovenTransaction): Either.Either<CoreWallet, WalletError>;
    balanceFallibleSection(secretKeys: ledger.ZswapSecretKeys, state: CoreWallet, imbalances: TransactionImbalances, coinSelection: CoinSelection<ledger.QualifiedShieldedCoinInfo>): Either.Either<{
        offer: ledger.ZswapOffer<ledger.PreProof> | undefined;
        newState: CoreWallet;
    }, WalletError>;
}
