// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Exit, Scope } from 'effect';
import * as rx from 'rxjs';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Variant, WalletRuntimeError } from './abstractions/index.js';
import { ObservableOps, HList } from '@midnight-ntwrk/wallet-sdk-utilities';
import * as Runtime from './Runtime.js';
/**
 * Builds a wallet-like implementation from a collection of wallet-like variants, each specific
 * to a given version of the Midnight protocol.
 *
 * @typeParam TBuilders The sequence of variant builders that will manage the wallet state
 */
export class WalletBuilder {
    constructor(buildState) {
        this.#buildState = buildState;
    }
    static init() {
        return new WalletBuilder({
            variants: [],
        });
    }
    #buildState;
    /**
     * Ensures that the built wallet uses a given variant.
     *
     * @param sinceVersion The Midnight protocol version that the variant should operate from.
     * @param variantBuilder A {@link VariantBuilder} that builds the variant.
     * @returns A new {@link WalletBuilder} that uses the variant that will be built from `variantBuilder`.
     */
    withVariant(sinceVersion, variantBuilder) {
        const { sinceVersion: previousVersion } = this.#buildState.variants.at(-1) ?? {
            sinceVersion: ProtocolVersion.ProtocolVersion(-1n),
        };
        if (sinceVersion <= previousVersion) {
            throw new Error('ProtocolMismatch: sinceVersion is prior to previously registered version');
        }
        const newBuilder = { sinceVersion, variantBuilder };
        return new WalletBuilder({
            variants: HList.append(this.#buildState.variants, newBuilder),
        });
    }
    /**
     * Builds a wallet like implementation.
     */
    build(...[maybeConfiguration]) {
        if (this.#buildState.variants.length == 0) {
            throw new WalletRuntimeError({ message: 'Empty variants list' });
        }
        const variants = this.#buildState.variants.map(({ sinceVersion, variantBuilder }) => ({
            sinceVersion,
            variant: variantBuilder.build(maybeConfiguration ?? {}),
        }));
        return class BaseWallet {
            static configuration = (maybeConfiguration ??
                {});
            static allVariants() {
                return variants;
            }
            static allVariantsRecord() {
                return Variant.makeVersionedRecord(BaseWallet.allVariants());
            }
            static startEmpty(WalletClass) {
                return Effect.gen(this, function* () {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    const initialState = yield* HList.head(BaseWallet.allVariants()).variant.migrateState(null);
                    return BaseWallet.startFirst(WalletClass, initialState);
                }).pipe(Effect.runSync);
            }
            static startFirst(WalletClass, state) {
                return Effect.gen(this, function* () {
                    const scope = yield* Scope.make();
                    const runtime = yield* Runtime.initHead({ variants, state }).pipe(Effect.provideService(Scope.Scope, scope));
                    return new WalletClass(runtime, scope);
                }).pipe(Effect.runSync);
            }
            static start(WalletClass, tag, state) {
                return Effect.gen(this, function* () {
                    const scope = yield* Scope.make();
                    const runtime = yield* Runtime.init({ variants, tag, state }).pipe(Effect.provideService(Scope.Scope, scope));
                    return new WalletClass(runtime, scope);
                }).pipe(Effect.runSync);
            }
            runtime;
            runtimeScope;
            rawState;
            get syncComplete() {
                const { sourceGap, applyGap } = Effect.runSync(this.runtime.progress);
                return sourceGap === 0n && applyGap === 0n;
            }
            constructor(runtime, runtimeScope) {
                this.runtime = runtime;
                this.runtimeScope = runtimeScope;
                this.rawState = ObservableOps.fromStream(runtime.stateChanges).pipe(rx.shareReplay({ refCount: true, bufferSize: 1 }));
            }
            stop() {
                return Scope.close(this.runtimeScope, Exit.void).pipe(Effect.runPromise);
            }
        };
    }
}
