// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { StateChange, VersionChangeType, WalletRuntimeError } from '../abstractions/index.js';
import { Effect, Option, PubSub, Stream } from 'effect';
export const Numeric = 'NumericRange';
export class NumericRange {
    __polyTag__ = Numeric;
    #state = 0;
    configuration;
    yieldCount;
    throwError;
    constructor(configuration, yieldCount, throwError) {
        this.throwError = throwError;
        this.yieldCount = yieldCount;
        this.configuration = configuration;
    }
    get currentState() {
        return this.#state;
    }
    start(context) {
        const max = this.configuration.max ?? 10;
        return context.stateRef.get.pipe(Effect.flatMap((state) => {
            return Effect.sync(() => {
                this.#state = state;
            });
        }), Effect.map(() => ({
            __polyTag__: Numeric,
            state: Stream.fromAsyncIterable(
            // eslint-disable-next-line @typescript-eslint/require-await
            (async function* (self) {
                for (let value = self.#state; value <= max; value++) {
                    self.#state = value;
                    yield StateChange.State({ state: value });
                    if (--self.yieldCount === 0) {
                        if (self.throwError) {
                            throw new Error('NumericRange: forced break');
                        }
                        yield StateChange.VersionChange({ change: VersionChangeType.Next() });
                    }
                }
            })(this), (e) => new WalletRuntimeError({ message: 'NumericRange error', cause: e })),
        })));
    }
    migrateState() {
        return Effect.succeed(0);
    }
}
export class NumericRangeBuilder {
    yieldCount;
    throwError;
    constructor(yieldCount = 10, throwError = false) {
        this.throwError = throwError;
        this.yieldCount = yieldCount;
    }
    build(configuration) {
        return new NumericRange(configuration, this.yieldCount, this.throwError);
    }
}
export const NumericMultiplier = 'NumericMultiplier';
export class NumericRangeMultiplier {
    __polyTag__ = NumericMultiplier;
    #state = 0;
    configuration;
    constructor(configuration) {
        this.configuration = configuration;
    }
    get currentState() {
        return this.#state;
    }
    start(context) {
        return context.stateRef.get.pipe(Effect.flatMap((state) => {
            return Effect.sync(() => {
                this.#state = state;
            });
        }), Effect.map(() => {
            const max = this.configuration.max ?? 10;
            return {
                __polyTag__: NumericMultiplier,
                state: Stream.fromIterable((function* (self) {
                    for (let value = self.#state; value <= max; value++) {
                        self.#state = value;
                        yield StateChange.State({ state: value * self.configuration.multiplier });
                    }
                    return Option.none();
                })(this)),
            };
        }));
    }
    migrateState(state) {
        return Effect.succeed(state + 1);
    }
}
export class NumericRangeMultiplierBuilder {
    build(configuration) {
        return new NumericRangeMultiplier(configuration);
    }
}
export class InterceptingVariant {
    __polyTag__;
    constructor(tag) {
        this.__polyTag__ = tag;
    }
    migrateState(previousState) {
        return Effect.succeed(previousState);
    }
    start(context) {
        const tag = this.__polyTag__;
        return Effect.gen(this, function* () {
            const pubsub = yield* PubSub.bounded({
                capacity: 1,
                replay: 1,
            });
            const state = yield* context.stateRef.get;
            yield* PubSub.publish(pubsub, StateChange.State({ state }));
            return {
                __polyTag__: tag,
                state: Stream.fromPubSub(pubsub, {
                    shutdown: true,
                }),
                emitProtocolVersionChange: (change) => {
                    return PubSub.publish(pubsub, StateChange.VersionChange({ change }));
                },
            };
        });
    }
}
/**
 * Builder of an intercepting variant
 * It allows removing the possibility of race conditions by requiring an explicit gesture to migrate to a next/specific protocol version
 */
export class InterceptingVariantBuilder {
    tag;
    constructor(tag) {
        this.tag = tag;
    }
    build() {
        return new InterceptingVariant(this.tag);
    }
}
