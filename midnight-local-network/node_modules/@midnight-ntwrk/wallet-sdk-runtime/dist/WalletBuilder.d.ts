import { Types } from 'effect';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { VariantBuilder, WalletLike } from './abstractions/index.js';
import { HList } from '@midnight-ntwrk/wallet-sdk-utilities';
/**
 * Builds a wallet-like implementation from a collection of wallet-like variants, each specific
 * to a given version of the Midnight protocol.
 *
 * @typeParam TBuilders The sequence of variant builders that will manage the wallet state
 */
export declare class WalletBuilder<TBuilders extends VariantBuilder.AnyVersionedVariantBuilder[]> {
    #private;
    private constructor();
    static init(): WalletBuilder<[]>;
    /**
     * Ensures that the built wallet uses a given variant.
     *
     * @param sinceVersion The Midnight protocol version that the variant should operate from.
     * @param variantBuilder A {@link VariantBuilder} that builds the variant.
     * @returns A new {@link WalletBuilder} that uses the variant that will be built from `variantBuilder`.
     */
    withVariant<TBuilder extends VariantBuilder.AnyVariantBuilder>(sinceVersion: ProtocolVersion.ProtocolVersion, variantBuilder: TBuilder): WalletBuilder<HList.Append<TBuilders, VariantBuilder.VersionedVariantBuilder<TBuilder>>>;
    /**
     * Builds a wallet like implementation.
     */
    build(...[maybeConfiguration]: WalletBuilder.BuildArguments<TBuilders>): WalletLike.BaseWalletClass<VariantBuilder.VersionedVariantsOf<TBuilders>, WalletBuilder.FullConfiguration<TBuilders>>;
}
export declare namespace WalletBuilder {
    /**
     * The internal build state of {@link WalletBuilder}.
     *
     * @remarks
     * Represents the collection of configured variants and their configuration.
     */
    type BuildState<TBuilders extends VariantBuilder.AnyVersionedVariantBuilder[]> = {
        readonly variants: TBuilders;
    };
    /**
     * Allows properly expressing no need for configuration if an empty one needs to be provided
     */
    type BuildArguments<TBuilders extends VariantBuilder.AnyVersionedVariantBuilder[]> = VoidIfEmpty<FullConfiguration<TBuilders>> extends undefined ? [] : [FullConfiguration<TBuilders>];
    type FullConfiguration<TBuilders extends VariantBuilder.AnyVersionedVariantBuilder[]> = Types.UnionToIntersection<Configurations<TBuilders>>;
    type VoidIfEmpty<TObject> = keyof TObject extends never ? undefined : TObject;
    type Configurations<TBuilders extends VariantBuilder.AnyVersionedVariantBuilder[]> = VariantBuilder.ConfigurationOf<HList.Each<TBuilders>>;
}
