import { Effect, Scope, Stream, SynchronizedRef } from 'effect';
import { ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Variant, WalletRuntimeError } from './abstractions/index.js';
import { HList, Poly } from '@midnight-ntwrk/wallet-sdk-utilities';
/**
 * The {@link Runtime} service type.
 */
export interface Runtime<Variants extends Variant.AnyVersionedVariantArray> {
    readonly stateChanges: Stream.Stream<ProtocolState.ProtocolState<Variant.StateOf<HList.Each<Variants>>>, WalletRuntimeError>;
    readonly progress: Effect.Effect<Progress>;
    readonly currentVariant: Effect.Effect<EachRunningVariant<Variants>>;
    dispatch<TResult, E = never>(impl: Poly.PolyFunction<Variant.RunningVariantOf<HList.Each<Variants>>, Effect.Effect<TResult, E>>): Effect.Effect<TResult, WalletRuntimeError | E>;
}
export type RunningVariant<TVariant extends Variant.AnyVersionedVariant, TRest extends Variant.AnyVersionedVariantArray> = Poly.WithTagFrom<TVariant['variant']> & {
    variant: TVariant;
    runningVariant: Variant.RunningVariantOf<TVariant>;
    initialState: Variant.StateOf<TVariant>;
    variantScope: Scope.CloseableScope;
    currentStateRef: SynchronizedRef.SynchronizedRef<Variant.StateOf<TVariant>>;
    restVariants: TRest;
    initProtocolVersion: ProtocolVersion.ProtocolVersion;
    validVersionRange: ProtocolVersion.ProtocolVersion.Range;
    nextProtocolVersion: ProtocolVersion.ProtocolVersion | null;
};
type EachRunningVariant<TAll extends Variant.AnyVersionedVariantArray> = TAll extends [
    infer THead extends Variant.AnyVersionedVariant,
    ...infer TRest extends Variant.AnyVersionedVariantArray
] ? RunningVariant<THead, TRest> | EachRunningVariant<TRest> : never;
/**
 * A type that represents the reported progress of a variant expressed in terms of gaps to reaching synced
 * progress in application site and data source site
 */
type Progress = {
    readonly sourceGap: bigint;
    readonly applyGap: bigint;
};
export type InitRuntimeHeadArgs<Variants extends Variant.AnyVersionedVariantArray> = {
    variants: Variants;
    state: Variant.StateOf<HList.Head<Variants>>;
};
export declare const initHead: <Variants extends Variant.AnyVersionedVariantArray>(initArgs: InitRuntimeHeadArgs<Variants>) => Effect.Effect<Runtime<Variants>, WalletRuntimeError, Scope.Scope>;
export type InitRuntimeArgs<Variants extends Variant.AnyVersionedVariantArray, InitTag extends string | symbol> = {
    variants: Variants;
    tag: InitTag;
    state: Variant.StateOf<HList.Find<Variants, {
        variant: Poly.WithTag<InitTag>;
    }>>;
};
export declare const init: <Variants extends Variant.AnyVersionedVariantArray, InitTag extends string | symbol>(initArgs: InitRuntimeArgs<Variants, InitTag>) => Effect.Effect<Runtime<Variants>, WalletRuntimeError, Scope.Scope>;
export declare const dispatch: <Variants extends Variant.AnyVersionedVariantArray, TResult, E = never>(runtime: Runtime<Variants>, impl: Poly.PolyFunction<Variant.RunningVariantOf<HList.Each<Variants>>, Effect.Effect<TResult, E>>) => Effect.Effect<TResult, WalletRuntimeError | E>;
export {};
