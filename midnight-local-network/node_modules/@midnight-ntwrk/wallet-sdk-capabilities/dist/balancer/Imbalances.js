export const Imbalances = new (class {
    empty = () => {
        return new Map();
    };
    fromEntry = (tokenType, value) => {
        return new Map([[tokenType, value]]);
    };
    fromEntries = (entries) => {
        const out = new Map();
        for (const [tokenType, value] of entries) {
            const existingValue = this.getValue(out, tokenType);
            out.set(tokenType, value + existingValue);
        }
        return out;
    };
    fromMap = (map) => {
        return this.fromEntries(map.entries());
    };
    fromMaybeMap = (map) => {
        return this.fromMap(map ?? new Map());
    };
    getValue = (map, tokenType) => {
        return map.get(tokenType) ?? 0n;
    };
    typeSet = (map) => {
        return new Set(map.keys());
    };
    ensureZerosFor(map, types) {
        const out = this.fromEntries(map.entries());
        for (const tokenType of types) {
            const existingValue = this.getValue(out, tokenType);
            out.set(tokenType, existingValue);
        }
        return out;
    }
    merge = (a, b) => {
        const allTokenTypes = this.typeSet(a).union(this.typeSet(b));
        return this.fromEntries(allTokenTypes
            .values()
            .map((tokenType) => {
            const aValue = this.getValue(a, tokenType);
            const bValue = this.getValue(b, tokenType);
            return [tokenType, aValue + bValue];
        })
            .filter(([, value]) => value !== 0n)
            .toArray());
    };
})();
