import { CounterOffer, TransactionCostModel } from './CounterOffer.js';
import { CoinRecipe, Imbalances, TokenType, TokenValue } from './Imbalances.js';
export declare class InsufficientFundsError extends Error {
    readonly tokenType: TokenType;
    constructor(tokenType: TokenType);
}
export interface BalanceRecipe<TInput extends CoinRecipe, TOutput extends CoinRecipe> {
    inputs: TInput[];
    outputs: TOutput[];
}
export type CoinSelection<TInput extends CoinRecipe> = (coins: readonly TInput[], tokenType: TokenType, amountNeeded: TokenValue, costModel: TransactionCostModel) => TInput | undefined;
export type BalanceRecipeProps<TInput extends CoinRecipe, TOutput extends CoinRecipe> = {
    coins: TInput[];
    initialImbalances: Imbalances;
    transactionCostModel: TransactionCostModel;
    feeTokenType: string;
    createOutput: (coin: CoinRecipe) => TOutput;
    isCoinEqual: (a: TInput, b: TInput) => boolean;
    coinSelection?: CoinSelection<TInput> | undefined;
    targetImbalances?: Imbalances;
};
export declare const getBalanceRecipe: <TInput extends CoinRecipe, TOutput extends CoinRecipe>({ coins, initialImbalances, transactionCostModel, feeTokenType, createOutput, coinSelection, isCoinEqual, targetImbalances, }: BalanceRecipeProps<TInput, TOutput>) => BalanceRecipe<TInput, TOutput>;
export declare const createCounterOffer: <TInput extends CoinRecipe, TOutput extends CoinRecipe>(coins: TInput[], initialImbalances: Imbalances, transactionCostModel: TransactionCostModel, feeTokenType: string, coinSelection: CoinSelection<TInput>, createOutput: (coin: CoinRecipe) => TOutput, isCoinEqual: (a: TInput, b: TInput) => boolean, targetImbalances?: Imbalances) => CounterOffer<TInput, TOutput>;
export declare const chooseCoin: <TInput extends CoinRecipe>(coins: readonly TInput[], tokenType: TokenType) => TInput | undefined;
