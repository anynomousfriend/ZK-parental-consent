// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { CounterOffer } from './CounterOffer.js';
export class InsufficientFundsError extends Error {
    tokenType;
    constructor(tokenType) {
        super(`Insufficient Funds: could not balance ${tokenType}`);
        this.tokenType = tokenType;
    }
}
export const getBalanceRecipe = ({ coins, initialImbalances, transactionCostModel, feeTokenType, createOutput, coinSelection, isCoinEqual, targetImbalances, }) => {
    const counterOffer = createCounterOffer(coins, initialImbalances, transactionCostModel, feeTokenType, coinSelection ?? chooseCoin, createOutput, isCoinEqual, targetImbalances);
    return {
        inputs: counterOffer.inputs,
        outputs: counterOffer.outputs,
    };
};
export const createCounterOffer = (coins, initialImbalances, transactionCostModel, feeTokenType, coinSelection, createOutput, isCoinEqual, targetImbalances = new Map()) => {
    const counterOffer = new CounterOffer(initialImbalances, transactionCostModel, feeTokenType, targetImbalances);
    let imbalance;
    while ((imbalance = counterOffer.findNonNativeImbalance())) {
        coins = doBalance(imbalance, coins, counterOffer, coinSelection, createOutput, isCoinEqual);
    }
    while ((imbalance = counterOffer.findNativeImbalance())) {
        coins = doBalance(imbalance, coins, counterOffer, coinSelection, createOutput, isCoinEqual);
    }
    return counterOffer;
};
const doBalance = (imbalance, coins, counterOffer, coinSelection, createOutput, isCoinEqual) => {
    const [tokenType, imbalanceAmount] = imbalance;
    const shouldAddOutput = (tokenType === counterOffer.feeTokenType &&
        imbalanceAmount >=
            counterOffer.getTargetImbalance(counterOffer.feeTokenType) +
                counterOffer.transactionCostModel.outputFeeOverhead) ||
        (tokenType !== counterOffer.feeTokenType && imbalanceAmount > counterOffer.getTargetImbalance(tokenType));
    if (shouldAddOutput) {
        const output = createOutput({
            type: tokenType,
            value: imbalanceAmount - counterOffer.getTargetImbalance(tokenType),
        });
        counterOffer.addOutput(output);
    }
    else {
        const coin = coinSelection(coins, tokenType, imbalanceAmount, counterOffer.transactionCostModel);
        if (typeof coin === 'undefined') {
            throw new InsufficientFundsError(tokenType);
        }
        counterOffer.addInput(coin);
        coins = coins.filter((c) => !isCoinEqual(c, coin));
    }
    return coins;
};
export const chooseCoin = (coins, tokenType) => {
    return coins
        .filter((coin) => coin.type === tokenType)
        .sort((a, b) => Number(a.value - b.value))
        .at(0);
};
